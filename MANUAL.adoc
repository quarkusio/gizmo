= Gizmo User's Manual
:preface-title: introduction
:docname: user-manual
:toc:

[id=introduction]
== Introduction

Gizmo 2 is a library whose purpose is to make it relatively easy to generate reasonably efficient class files.

The API is loosely modeled after the https://openjdk.org/jeps/484[JDK class file API], in that elements are modeled using lexical scoping.
In contrast however, many things which would otherwise be subtly confusing or difficult are simplified considerably.

Since this library is used to build programs in a way that approximates the Java language itself, it contains many method names that conflict with Java keywords.
In these cases, the method name has a `\_` character appended to the method name (for example, `class_`, `switch_`, or `goto_`).

This library is an evolution of the earlier Gizmo 1 library with further conceptual simplifications and capabilities.
While Gizmo 2 is not source- or binary-compatible with Gizmo 1, it resides in a non-conflicting package space, so the two can coexist during a transition period of migrating from 1 to 2.

[id=quick-start]
== Quick start

To get started quickly, include the `io.quarkus.gizmo:gizmo2` artifact in your project build. The following code blob shows how to generate a simple class:

."Hello world" example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;

public class HelloWorld {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("HelloWorldGenerated", cc -> {
            zc.staticMethod("main", mc -> {
                mc.public_();
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Hello world!%n");
                    b0.return_();
                });
            });
        });
    }
}
----

[id=gizmo-interface]
== The `Gizmo` interface

The `Gizmo` interface is the primary entry point into the API.
Instances are created using the `Gizmo.create(...)` method, which accepts a <<classoutput>> instance.

The `Gizmo` instance can be used to create classes and interfaces, and can also be used to create derived `Gizmo` instances which have different defaults for access modifiers or a different <<classoutput>>.

[id=classoutput]
=== `ClassOutput`

Implementations of the `ClassOutput` interface receive the bytes of the generated classes and resources.

Users may implement this interface directly or use a provided implementation.

The `ClassOutput.fileWriter(Path)` static factory method returns a `ClassWriter` which writes classes and resources under the given target path.

[id=descriptors]
== Descriptors

The class file format itself encodes types and members using "descriptors", which are strings which unambiguously identify them.
Gizmo 2 uses object abstractions of these strings for convenience and safety.
Some of these object types are provided by the JDK, and others are defined by Gizmo.

[id=classdesc]
=== The `ClassDesc` interface

Types (primitives, classes and interfaces and their variations, and arrays) are identified using the `ClassDesc` interface, which is provided by the JDK as part of the `java.lang.constant` package.
Instances can be created using the various factory methods of that class.

.Example of creating a class descriptor for `java.lang.String`
[source,java]
----
import java.lang.constant.ClassDesc;

public static class ClassDescExample {
    public static void main(String[] args) {
        System.out.printf("The descriptor of String is: %s%n", ClassDesc.of("java.lang.String"));
    }
}
----

A class descriptor can also be derived from a `Class<?>` object by calling its `describeConstable` method.
Note that https://openjdk.org/jeps/371[hidden classes] will return an empty `Optional` from this method.

Since hidden classes are uncommon, the `Reflection2Gizmo.classDescOf(...)` method takes a `Class` and returns a `ClassDesc` directly.
In case of a hidden class (if you can obtain its `Class` object), this method throws an exception.

[id=fielddesc]
=== The `FieldDesc` interface

Fields are identified by the combination of the "owner" type (represented as a <<classdesc,`ClassDesc`>>), the field name (a `String`), and the field's type (another `ClassDesc`).
This is true for both static and instance fields, which therefore share an overall namespace.
In Gizmo, these identifiers are represented using the `FieldDesc` interface, which contains several factory methods for easy usage.

.Examples of various field descriptors
[source,java]
----
import java.io.PrintStream;
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.desc.FieldDesc;

public class FieldDescExample {
    public static void main(String[] args) {
        FieldDesc sysOut = FieldDesc.of(System.class, "out"); // the type is detected via reflection
        FieldDesc sysErr = FieldDesc.of(
            ClassDesc.of("java.lang.System"),
            "err",
            PrintStream.class
        );
        FieldDesc sysIn = FieldDesc.of(
            ClassDesc.of("java.lang.System"),
            "in",
            ClassDesc.of("java.io.InputStream")
        );
    }
}

----

[id=methoddesc]
=== `MethodDesc` and `ConstructorDesc`

Within the JVM, methods and constructors are represented the same way (the latter bearing the special name `<init>` and always returning `void`, but otherwise having the same structure).
Methods and constructors are uniquely identified by the combination of the "owner" type (a <<classdesc,`ClassDesc`>>), the member name (a `String`), and the type (a <<methodtypedesc,`MethodTypeDesc`>>).

Gizmo 2 represents these identifiers using the `MethodDesc` and `ConstructorDesc` interfaces.
Furthermore, the JVM makes a distinction between methods which exist on interfaces (and their derived types) versus methods which exist on classes (and their derived types).
This distinction is represented using the `ClassMethodDesc` and `InterfaceMethodDesc` sub-interfaces.

A `MethodDesc` can be constructed using reflection-based factory methods on the base `MethodDesc` interface.
These methods will automatically determine whether a `ClassMethodDesc` or `InterfaceMethodDesc` should be returned, based on the owner `Class` instance that is provided to these methods.

If the owner's `Class` instance is not readily available (for example, if it is a generated class or one not visible to the generator's class loader), then the factory methods on `ClassMethodDesc` and `InterfaceMethodDesc` may be used to return an instance of that type.

Since a `ConstructorDesc` always returns `void`, any attempt to create a `ConstructorDesc` with a non-`void` return type will result in an exception.

There are a wide variety of factory methods available for these types.
A few of the common ones are illustrated below.

.Examples of various method and constructor descriptors
[source,java]
----
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.desc.ConstructorDesc;
import io.quarkus.gizmo2.desc.MethodDesc;
import io.quarkus.gizmo2.desc.ClassMethodDesc;
import io.quarkus.gizmo2.desc.InterfaceMethodDesc;

public class MethodDescExample {
    public static void main(String[] args) {
        ConstructorDesc stringCtor = ConstructorDesc.of(String.class, char[].class);

        MethodDesc hashCodeDesc = MethodDesc.of(Object.class, "hashCode", int.class);
        MethodDesc runDesc = InterfaceMethodDesc.of(
            ClassDesc.of("java.lang.Runnable"),
            "run",
            void.class
        );
        MethodDesc toStringDesc = ClassMethodDesc.of(
            ClassDesc.of("java.lang.Object"),
            "toString",
            String.class
        );
    }
}
----

[id=methodtypedesc]
=== The `MethodTypeDesc` interface

The type of a method or constructor is determined by its return and parameter types.
The JDK represents this type using the `MethodTypeDesc` interface in the `java.lang.constant` package.
This interface contains a factory method to compose instances from constituent <<classdesc,ClassDesc>> instances.

.Example of creating a `MethodTypeDesc`
[source,java]
----
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;

public class MethodTypeDescExample {
    public static void main(String[] args) {
        ClassDesc stringArray = ClassDesc.of("java.lang.String").arrayType();
        MethodTypeDesc mainType = MethodTypeDesc.of(
            ClassDesc.ofDescriptor("V"), // void
            stringArray
        );
    }
}
----

[id=creating-types]
== Creating types

Types may be created directly using methods on the <<gizmo-interface,`Gizmo`>> interface.
The general form of these methods accepts a consumer of a `ClassCreator` or `InterfaceCreator` instance, which is then used to construct the type and its constituent members.
Normally, an in-line lambda expression is used for this argument, which creates a lexical structure which is similar to that of a type definition in Java.
By convention, the parameter name `cc` is typically used for the `ClassCreator` or `InterfaceCreator` instance.

The creator instance passed to the consumer may add or remove flags, set the access level, modify the class version, extend interfaces or a base class, and add members to the type.

.Example of creating a simple class
[source,java]
----
import java.io.Serializable;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.ClassVersion;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class SimpleClassExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new class using the given lambda
        gizmo.class_("com.mycompany.SomeClass", cc -> {
            // we can implement interfaces
            cc.implements_(Serializable.class);
            // we can extend base classes
            cc.extends_(RuntimeException.class);
            // we can set flags
            cc.final_();
            // or...
            cc.addFlags(ModifierFlag.FINAL);
            // we can remove flags
            cc.removeFlag(ModifierFlag.SYNTHETIC);
            // we can set the access level
            cc.setAccess(AccessLevel.PACKAGE_PRIVATE);
            // or...
            cc.packagePrivate();
            // we can set the class version
            cc.setVersion(ClassVersion.V17);
        });
        // at this point, the class has been written to the output
    }
}
----

.Example of creating a simple interface
[source,java]
----
import java.io.Serializable;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.ClassVersion;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class SimpleInterfaceExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new interface using the given lambda
        gizmo.interface_("com.mycompany.SomeInterface", cc -> {
            // we can extend other interfaces
            cc.extends_(Serializable.class);
            cc.extends_(Cloneable.class);
            // we can set flags
            cc.addFlags(ModifierFlag.SYNTHETIC);
            // we can remove flags
            cc.removeFlag(ModifierFlag.SYNTHETIC);
            // we can set the access level
            cc.public_();
            // or...
            cc.setAccess(AccessLevel.PUBLIC);
            // we can set the class version
            cc.setVersion(ClassVersion.V17);
        });
    }
}
----

[id=creating-fields]
== Creating fields

Fields may be added to types using the `field`, `staticField`, and `constantField` methods.
These methods accept a consumer for a `StaticFieldCreator` or `InstanceFieldCreator` instance.
The `field` method returns a <<fielddesc,`FieldDesc`>> for the newly created field.
The `staticField` and `constantField` methods return a <<fields,`StaticFieldVar`>> which may be used directly in expressions.

Fields may be initialized directly with a constant value at the time the field is defined by using the `setInitial` method.
For more complex initializers, the `setInitializer` method may be used, which accepts a <<blocks,code block creator>> which must yield a value for the field.
Initializers are automatically emitted into constructors or static initializers in the order that they are established.

By convention, the parameter name `fc` is typically used for the `FieldCreator` instance.

.Example of creating a class with some fields
[source,java]
----
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ClassWithFieldsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new class using the given lambda
        gizmo.class_("com.mycompany.ClassWithFields", cc -> {
            // implicitly `int` because of the constant initializer
            cc.field("count", Const.of(123));
            // a more complex field
            cc.field("name", fc -> {
                fc.public_();
                fc.final_();
                fc.addFlag(ModifierFlag.TRANSIENT);
                // implicitly a `String` because of the initializer
                fc.setInitial("A more complex field");
            });
            // a field with a specified type and no initializer
            cc.field("problem", fc -> {
                fc.private_();
                fc.setType(Throwable.class);
            });
            // a public static final constant field
            cc.constantField("KIBI", Const.of(1024));
            // a regular static field
            cc.staticField("closed", fc -> {
                fc.volatile_();
                fc.setType(boolean.class);
            });
            // static fields may be final as well
            var nameArray = cc.staticField("nameArray", fc -> {
                fc.setType(String[].class);
                fc.final_();
                // initialize here or separately
            });
            // a more complex initializer example
            cc.field("namesAsList", fc -> {
                fc.setType(List.class);
                // blocks and expressions are covered elsewhere
                fc.setInitializer(b0 -> {
                    b0.yield(
                        b0.invokeStatic(
                            MethodDesc.of(Arrays.class, "asList", List.class, Object[].class),
                            b0.get(nameArray)
                        )
                    );
                });
            });
        });
    }
}
----

[id=creating-methods]
== Creating methods and constructors

Methods and constructors are created using one of several methods on the type creator instance.
The method used depends on the properties of the constructor or method being built, and the kind of type that the method or constructor belongs to.
They are as follows:

* `staticMethod(...)` creates a static method on a class or interface
* `ClassCreator.method(...)` creates a concrete instance method on a class
* `ClassCreator.abstractMethod(...)` creates an abstract instance method on a class
* `ClassCreator.staticNativeMethod(...)` creates a static native method on a class
* `ClassCreator.nativeMethod(...)` creates an instance native method on a class
* `ClassCreator.constructor(...)` creates a constructor on a class
* `ClassCreator.defaultConstructor()` causes the default no-argument constructor to be generated
* `InterfaceCreator.method(...)` creates an abstract instance method on an interface
* `InterfaceCreator.defaultMethod(...)` creates a default instance method on an interface
* `InterfaceCreator.privateMethod(...)` creates a private instance method on an interface

In some cases, there may be an implicit modifier or access level that cannot be changed on that particular member.
For example, interface private methods are always `private`, and abstract methods are always `abstract`.
It is not possible to change these modifier flags or access levels.
See <<modifiers>> for more information.

The method and constructor factory methods generally follow three different forms:

* A form which accepts <<methoddesc,a descriptor>> plus a creator consumer
* A form which accepts a name plus a creator consumer
* A form which accepts a name and a <<methodtypedesc,type descriptor>> plus a creator consumer

Note that the constructor factory methods do not accept a name argument.

If the type is given (either by giving the constructor/method descriptor or by giving the type descriptor), then the constructor's or method's <<parameters,parameter definitions>> (if any) must conform to the type given; otherwise, an error will be produced when the constructor or method is defined.

If the type is not given, it will be computed based on the types of the parameter definitions (if any) plus the return type (which defaults to `void`, and which cannot be changed for constructors).

The following is an example of defining constructors and methods.
Note that constructors and some types of methods have bodies containing program code, which is covered in more detail in the <<blocks>> section, and other features such as <<annotations,annotations>> and <<modifiers,access levels and modifiers>> which are explained in their respective sections.

.Example of defining constructors and methods
[source,java]
----
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.This;
import io.quarkus.gizmo2.creator.BlockCreator;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.desc.FieldDesc;
import io.quarkus.gizmo2.desc.MethodDesc;

public class TypesWithMethodsAndConstructorsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // an interface to implement
        ClassDesc nh = gizmo.interface_("org.numberifier.NumberHolder", cc -> {
            cc.method("incrementNumber", mc -> {
                mc.public_();
                mc.returning(int.class);
                // no body on interface method
            });
            cc.defaultMethod("setNumber", mc -> {
                ParamVar newNumber = mc.parameter("newNumber", int.class);
                // returns void by default; just return without doing anything
                mc.body(BlockCreator::return_);
            });
            cc.staticMethod("newInstance", mc -> {
                // return an instance of this interface
                mc.returning(cc.type());
                mc.public_();
                mc.body(b0 -> {
                    b0.return_(
                        b0.new_(ClassDesc.of("org.numberifier.NumberHolderImpl"))
);
                });
            });
        });

        // a base class to extend
        ClassDesc anh = gizmo.class_("org.numberifier.AbstractNumberHolder", cc -> {
            cc.implements_(nh);
            cc.abstract_();
            cc.abstractMethod("incrementNumber", mc -> {
                mc.addAnnotation(Override.class);
                mc.public_();
                mc.returning(void.class);
            });
        });

        // the leaf class
        gizmo.class_("org.numberifier.NumberHolderImpl", cc -> {
            cc.extends_(anh);
            // add some fields for context
            FieldDesc numberDesc = cc.field("number", Const.of(100));
            // add a default ctor
            cc.defaultConstructor();
            // we need this in order for our instance methods to do something interesting
            This this_ = cc.this_();
            // add a non-public ctor with an implicitly defined type
            cc.constructor(mc -> {
                mc.packagePrivate();
                ParamVar number = mc.parameter("number", int.class);
                mc.body(b0 -> {
                    b0.set(this_.field(numberDesc), number);
                    b0.return_();
                });
            });
            // method with implicitly defined type
            cc.method("incrementNumber", mc -> {
                mc.addAnnotation(Override.class);
                mc.public_();
                mc.returning(int.class);
                mc.body(b0 -> {
                    b0.inc(this_.field(numberDesc));
                    b0.return_(this_.field(numberDesc));
                });
            });
            // method with explicitly defined type
            cc.method("setNumber", MethodTypeDesc.of(
                ClassDesc.ofDescriptor("V"),
                ClassDesc.ofDescriptor("I")
            ), mc -> {
                mc.addAnnotation(Override.class);
                // parameters must match
                ParamVar newNumber = mc.parameter("newNumber");
                mc.body(b0 -> {
                    b0.set(this_.field(numberDesc), newNumber);
                    b0.return_();
                });
            });
        });
    }
}
----

Conventionally, we use `mc` as the name of the lambda parameter which accepts the method or constructor builder.
Since `cc` is conventionally used for classes, we use `mc` even for constructors.

[id=parameters]
=== Parameters

Methods and constructors may optionally accept parameters.
Parameters are declared using the `parameter(...)` method as shown in the example above.
The return value of the `parameter(...)` method is an object of type `ParamVar` which may be used as a variable (see <<local-vars>> for information about accessing variable values).

All parameters must be defined before defining the body of the method or constructor.
If the method or constructor was defined with a type, the defined parameters must match the number and type of parameters in the type.
Otherwise, the type of the method or constructor is derived from the parameters (and the return type, in the case of constructors).

[id=initializers]
=== Initializers

As a special case of constructors, static and instance initializers may be added to types as well.
Static initializers may be added to classes or interfaces using the `staticInitializer(...)` method.
Instance initializers only apply to classes, and may be defined using the `initializer(...)` method.

All defined static initializers and static field initializers are assembled into a single static initializer analogously to how the Java compiler does so, in order of definition.

Instance initializers and instance field initializers are all assembled into a single code block, which is then automatically replicated into each instance constructor.

[id=modifiers]
== Access levels and modifiers

[id=writing-instructions]
=== Writing instructions

[id=blocks]
== Blocks

[id=scoping]
=== Scoping

[id=expressions]
== Expressions

[id=expressions-use]
=== How to use expressions correctly

[id=types]
=== Types

[id=constants]
=== Constants

[id=const]
==== The `Const` interface

[id=jdk-const]
==== The `ConstantDesc` and `Constable` interfaces

[id=condy]
==== Dynamic constants

[id=this]
=== The special `this` expression

[id=assignable]
=== Assignable expressions

[id=local-vars]
==== Local variables

[id=fields]
==== Field expressions

[id=array-elements]
==== Array element expressions

[id=variable-use]
==== Using variable values

[id=variable-mutate]
==== Mutating variables

[id=variable-atomics]
==== Atomic operations on variables

[id=void-expr]
=== Void expressions

[id=yielding]
=== Yielding values from blocks

[id=arithmetic]
=== Arithmetic expressions

xxx: `add`/`sub`/`mul`/`div`/`mod`/`neg`

[id=bitwise-logic]
=== Bitwise logical expressions

xxx: `and`/`or`/`xor`/`complement`

[id=bitwise-shift]
=== Bitwise shifting expressions

xxx: `shl`/`shr`/`ushr`

[id=relational]
=== Relational expressions

[id=equality]
==== Equality/inequality

xxx: `eq`/`ne`

[id=numerical-relations]
==== Numerical relations

xxx: `lt`/`le`/`gt`/`ge`

[id=comparator-like]
==== Comparator-like operations

xxx: `cmp`/`cmpl`/`cmpg`

[id=invocation]
=== Invocation expressions

[id=invoke-static]
==== `invokeStatic`

[id=invoke-virtual]
==== `invokeVirtual`

[id=invoke-interface]
==== `invokeInterface`

[id=invoke-special]
==== `invokeSpecial`

[id=new]
=== `new` expression

[id=new-array]
=== `newArray` expression

[id=anonymous]
=== Anonymous class expressions

[id=lambdas]
=== Lambda expressions

[id=control]
== Control flow

[id=block]
=== `block`

[id=break]
=== `break`

[id=goto]
=== `goto`/`gotoStart`

[id=if]
=== `if`/`cond`

[id=logical]
=== `logicalAnd`/`logicalOr`

[id=switch]
=== `switch` and `switchEnum`

[id=goto-case]
==== `gotoCase`/`gotoDefault`

[id=loop]
=== `loop`

[id=while]
=== `while`/`doWhile`

[id=for-each]
=== `forEach`

[id=continue]
=== `continue_`

[id=try]
=== `try_`

[id=synchronized]
=== `synchronized_`

[id=auto-close]
=== `autoClose`

[id=annotations]
== Adding annotations

(TODO more detail)

[id=helpers]
== Helper methods

[id=assertions]
=== Assertions

[id=expr-equals]
=== `exprEquals`/`exprHashCode`/`exprToString`

[id=array-equals]
=== `arrayEquals`/`arrayHashCode`/`arrayToString`

[id=class-for-name]
=== `classForName`

[id=close]
=== `close`/`autoClose`

[id=iterate]
=== `iterate`

[id=current-thread]
=== `currentThread`

[id=optional]
=== `optionalOf`/`optionalOfNullable`

[id=collection-of]
=== `mapOf`/`setOf`/`listOf`/`mapEntryOf`

[id=swap]
=== `swap`/`rotate`

[id=boxing]
=== `box`/`unbox`

[id=locked]
=== `locked`

[id=fences]
=== Fences

[id=wrappers]
== Object wrappers

(TODO list them)

[id=generic-type]
== Generic types and type annotations

[id=building-generic-types]
=== Building generic types

[id=type-variables]
=== Adding type variables

[id=debugging]
== Debugging tips

[id=source-file-line]
=== Adding source file name and line numbers
