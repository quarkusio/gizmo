= Gizmo User's Manual
:preface-title: introduction
:docname: user-manual
:toc:

[id=introduction]
== Introduction

Gizmo 2 is a library whose purpose is to make it relatively easy to generate reasonably efficient class files.

The API is loosely modeled after the https://openjdk.org/jeps/484[JDK class file API], in that elements are modeled using lexical scoping.
In contrast however, many things which would otherwise be subtly confusing or difficult are simplified considerably.

Since this library is used to build programs in a way that approximates the Java language itself, it contains many method names that conflict with Java keywords.
In these cases, the method name has a `\_` character appended to the method name (for example, `class_`, `switch_`, or `goto_`).

This library is an evolution of the earlier Gizmo 1 library with further conceptual simplifications and capabilities.
While Gizmo 2 is not source- or binary-compatible with Gizmo 1, it resides in a non-conflicting package space, so the two can coexist during a transition period of migrating from 1 to 2.

[id=quick-start]
== Quick start

To get started quickly, include the `io.quarkus.gizmo:gizmo2` artifact in your project build. The following code blob shows how to generate a simple class:

."Hello world" example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;

public class HelloWorld {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("HelloWorldGenerated", cc -> {
            zc.staticMethod("main", mc -> {
                mc.public_();
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Hello world!%n");
                    b0.return_();
                });
            });
        });
    }
}
----

[id=gizmo-interface]
== The `Gizmo` interface

The `Gizmo` interface is the primary entry point into the API.
Instances are created using the `Gizmo.create(...)` method, which accepts a <<classoutput>> instance.

The `Gizmo` instance can be used to create classes and interfaces, and can also be used to create derived `Gizmo` instances which have different defaults for access modifiers or a different <<classoutput>>.

[id=classoutput]
=== `ClassOutput`

Implementations of the `ClassOutput` interface receive the bytes of the generated classes and resources.

Users may implement this interface directly or use a provided implementation.

The `ClassOutput.fileWriter(Path)` static factory method returns a `ClassWriter` which writes classes and resources under the given target path.

[id=descriptors]
== Descriptors

[id=classdesc]
=== The `ClassDesc` interface

[id=fielddesc]
=== The `FieldDesc` interface

[id=methoddesc]
=== `MethodDesc` and `ConstructorDesc`

[id=methodtypedesc]
=== The `MethodTypeDesc` interface

[id=creating-types]
== Creating types

[id=creating-fields]
== Creating fields

[id=creating-methods]
== Creating methods and constructors

[id=modifiers]
== Access levels and modifiers

[id=writing-instructions]
=== Writing instructions

[id=blocks]
== Blocks

[id=scoping]
=== Scoping

[id=expressions]
== Expressions

[id=expressions-use]
=== How to use expressions correctly

[id=types]
=== Types

[id=constants]
=== Constants

[id=const]
==== The `Const` interface

[id=jdk-const]
==== The `ConstantDesc` and `Constable` interfaces

[id=condy]
==== Dynamic constants

[id=this]
=== The special `this` expression

[id=assignable]
=== Assignable expressions

[id=local-vars]
==== Local variables

[id=fields]
==== Field expressions

[id=array-elements]
==== Array element expressions

[id=variable-use]
==== Using variable values

[id=variable-mutate]
==== Mutating variables

[id=variable-atomics]
==== Atomic operations on variables

[id=void-expr]
=== Void expressions

[id=yielding]
=== Yielding values from blocks

[id=arithmetic]
=== Arithmetic expressions

xxx: `add`/`sub`/`mul`/`div`/`mod`/`neg`

[id=bitwise-logic]
=== Bitwise logical expressions

xxx: `and`/`or`/`xor`/`complement`

[id=bitwise-shift]
=== Bitwise shifting expressions

xxx: `shl`/`shr`/`ushr`

[id=relational]
=== Relational expressions

[id=equality]
==== Equality/inequality

xxx: `eq`/`ne`

[id=numerical-relations]
==== Numerical relations

xxx: `lt`/`le`/`gt`/`ge`

[id=comparator-like]
==== Comparator-like operations

xxx: `cmp`/`cmpl`/`cmpg`

[id=invocation]
=== Invocation expressions

[id=invoke-static]
==== `invokeStatic`

[id=invoke-virtual]
==== `invokeVirtual`

[id=invoke-interface]
==== `invokeInterface`

[id=invoke-special]
==== `invokeSpecial`

[id=new]
=== `new` expression

[id=new-array]
=== `newArray` expression

[id=anonymous]
=== Anonymous class expressions

[id=lambdas]
=== Lambda expressions

[id=control]
== Control flow

[id=block]
=== `block`

[id=break]
=== `break`

[id=goto]
=== `goto`/`gotoStart`

[id=if]
=== `if`/`cond`

[id=logical]
=== `logicalAnd`/`logicalOr`

[id=switch]
=== `switch` and `switchEnum`

[id=goto-case]
==== `gotoCase`/`gotoDefault`

[id=loop]
=== `loop`

[id=while]
=== `while`/`doWhile`

[id=for-each]
=== `forEach`

[id=continue]
=== `continue_`

[id=try]
=== `try_`

[id=synchronized]
=== `synchronized_`

[id=auto-close]
=== `autoClose`

[id=annotations]
== Adding annotations

(TODO more detail)

[id=helpers]
== Helper methods

[id=assertions]
=== Assertions

[id=expr-equals]
=== `exprEquals`/`exprHashCode`/`exprToString`

[id=array-equals]
=== `arrayEquals`/`arrayHashCode`/`arrayToString`

[id=class-for-name]
=== `classForName`

[id=close]
=== `close`/`autoClose`

[id=iterate]
=== `iterate`

[id=current-thread]
=== `currentThread`

[id=optional]
=== `optionalOf`/`optionalOfNullable`

[id=collection-of]
=== `mapOf`/`setOf`/`listOf`/`mapEntryOf`

[id=swap]
=== `swap`/`rotate`

[id=boxing]
=== `box`/`unbox`

[id=locked]
=== `locked`

[id=fences]
=== Fences

[id=wrappers]
== Object wrappers

(TODO list them)

[id=generic-type]
== Generic types and type annotations

[id=building-generic-types]
=== Building generic types

[id=type-variables]
=== Adding type variables

[id=debugging]
== Debugging tips

[id=source-file-line]
=== Adding source file name and line numbers
