= Gizmo User's Manual
:preface-title: introduction
:docname: user-manual
:toc:

[id=introduction]
== Introduction

Gizmo 2 is a library whose purpose is to make it relatively easy to generate reasonably efficient class files.

The API is loosely modeled after the https://openjdk.org/jeps/484[JDK class file API], in that elements are modeled using lexical scoping.
In contrast however, many things which would otherwise be subtly confusing or difficult are simplified considerably.

Since this library is used to build programs in a way that approximates the Java language itself, it contains many method names that conflict with Java keywords.
In these cases, the method name has a `\_` character appended to the method name (for example, `class_`, `switch_`, or `goto_`).

This library is an evolution of the earlier Gizmo 1 library with further conceptual simplifications and capabilities.
While Gizmo 2 is not source- or binary-compatible with Gizmo 1, it resides in a non-conflicting package space, so the two can coexist during a transition period of migrating from 1 to 2.

[id=quick-start]
== Quick start

To get started quickly, include the `io.quarkus.gizmo:gizmo2` artifact in your project build. The following code blob shows how to generate a simple class:

//TEST:BEGIN
."Hello world" example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;

public class HelloWorld {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("HelloWorldGenerated", cc -> {
            cc.staticMethod("main", mc -> {
                mc.public_();
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Hello world!%n");
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN HelloWorldGenerated
//= Hello world!
//TEST:END

[id=gizmo-interface]
== The `Gizmo` interface

The `Gizmo` interface is the primary entry point into the API.
Instances are created using the `Gizmo.create(...)` method, which accepts a <<classoutput>> instance.

The `Gizmo` instance can be used to create classes and interfaces, and can also be used to create derived `Gizmo` instances which have different defaults for access modifiers or a different <<classoutput>>.

[id=classoutput]
=== `ClassOutput`

Implementations of the `ClassOutput` interface receive the bytes of the generated classes and resources.

Users may implement this interface directly or use a provided implementation.

The `ClassOutput.fileWriter(Path)` static factory method returns a `ClassWriter` which writes classes and resources under the given target path.

[id=descriptors]
== Descriptors

The class file format itself encodes types and members using "descriptors", which are strings which unambiguously identify them.
Gizmo 2 uses object abstractions of these strings for convenience and safety.
Some of these object types are provided by the JDK, and others are defined by Gizmo.

[id=classdesc]
=== The `ClassDesc` interface

Types (primitives, classes and interfaces and their variations, and arrays) are identified using the `ClassDesc` interface, which is provided by the JDK as part of the `java.lang.constant` package.
Instances can be created using the various factory methods of that class.

//TEST:BEGIN
.Example of creating a class descriptor for `java.lang.String`
[source,java]
----
import java.lang.constant.ClassDesc;

public class ClassDescExample {
    public static void main(String[] args) {
        System.out.printf("The descriptor of String is: %s%n", ClassDesc.of("java.lang.String"));
    }
}
----
//TEST:OUTPUT
//~ The descriptor of String is: .*
//TEST:END

A class descriptor can also be derived from a `Class<?>` object by calling its `describeConstable` method.
Note that https://openjdk.org/jeps/371[hidden classes] will return an empty `Optional` from this method.

Since hidden classes are uncommon, the `Reflection2Gizmo.classDescOf(...)` method takes a `Class` and returns a `ClassDesc` directly.
In case of a hidden class (if you can obtain its `Class` object), this method throws an exception.

[id=fielddesc]
=== The `FieldDesc` interface

Fields are identified by the combination of the "owner" type (represented as a <<classdesc,`ClassDesc`>>), the field name (a `String`), and the field's type (another `ClassDesc`).
This is true for both static and instance fields, which therefore share an overall namespace.
In Gizmo, these identifiers are represented using the `FieldDesc` interface, which contains several factory methods for easy usage.

//TEST:BEGIN
.Examples of various field descriptors
[source,java]
----
import java.io.PrintStream;
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.desc.FieldDesc;

public class FieldDescExample {
    public static void main(String[] args) {
        FieldDesc sysOut = FieldDesc.of(System.class, "out"); // the type is detected via reflection
        FieldDesc sysErr = FieldDesc.of(
            ClassDesc.of("java.lang.System"),
            "err",
            PrintStream.class
        );
        FieldDesc sysIn = FieldDesc.of(
            ClassDesc.of("java.lang.System"),
            "in",
            ClassDesc.of("java.io.InputStream")
        );
    }
}

----
//TEST:END

[id=methoddesc]
=== `MethodDesc` and `ConstructorDesc`

Within the JVM, methods and constructors are represented the same way (the latter bearing the special name `<init>` and always returning `void`, but otherwise having the same structure).
Methods and constructors are uniquely identified by the combination of the "owner" type (a <<classdesc,`ClassDesc`>>), the member name (a `String`), and the type (a <<methodtypedesc,`MethodTypeDesc`>>).

Gizmo 2 represents these identifiers using the `MethodDesc` and `ConstructorDesc` interfaces.
Furthermore, the JVM makes a distinction between methods which exist on interfaces (and their derived types) versus methods which exist on classes (and their derived types).
This distinction is represented using the `ClassMethodDesc` and `InterfaceMethodDesc` sub-interfaces.

A `MethodDesc` can be constructed using reflection-based factory methods on the base `MethodDesc` interface.
These methods will automatically determine whether a `ClassMethodDesc` or `InterfaceMethodDesc` should be returned, based on the owner `Class` instance that is provided to these methods.

If the owner's `Class` instance is not readily available (for example, if it is a generated class or one not visible to the generator's class loader), then the factory methods on `ClassMethodDesc` and `InterfaceMethodDesc` may be used to return an instance of that type.

Since a `ConstructorDesc` always returns `void`, any attempt to create a `ConstructorDesc` with a non-`void` return type will result in an exception.

There are a wide variety of factory methods available for these types.
A few of the common ones are illustrated below.

//TEST:BEGIN
.Examples of various method and constructor descriptors
[source,java]
----
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.desc.ConstructorDesc;
import io.quarkus.gizmo2.desc.MethodDesc;
import io.quarkus.gizmo2.desc.ClassMethodDesc;
import io.quarkus.gizmo2.desc.InterfaceMethodDesc;

public class MethodDescExample {
    public static void main(String[] args) {
        ConstructorDesc stringCtor = ConstructorDesc.of(String.class, char[].class);

        MethodDesc hashCodeDesc = MethodDesc.of(Object.class, "hashCode", int.class);
        MethodDesc runDesc = InterfaceMethodDesc.of(
            ClassDesc.of("java.lang.Runnable"),
            "run",
            void.class
        );
        MethodDesc toStringDesc = ClassMethodDesc.of(
            ClassDesc.of("java.lang.Object"),
            "toString",
            String.class
        );
    }
}
----
//TEST:END

[id=methodtypedesc]
=== The `MethodTypeDesc` interface

The type of a method or constructor is determined by its return and parameter types.
The JDK represents this type using the `MethodTypeDesc` interface in the `java.lang.constant` package.
This interface contains a factory method to compose instances from constituent <<classdesc,ClassDesc>> instances.

//TEST:BEGIN
.Example of creating a `MethodTypeDesc`
[source,java]
----
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;

public class MethodTypeDescExample {
    public static void main(String[] args) {
        ClassDesc stringArray = ClassDesc.of("java.lang.String").arrayType();
        MethodTypeDesc mainType = MethodTypeDesc.of(
            ClassDesc.ofDescriptor("V"), // void
            stringArray
        );
    }
}
----
//TEST:END

[id=creating-types]
== Creating types

Types may be created directly using methods on the <<gizmo-interface,`Gizmo`>> interface.
The general form of these methods accepts a consumer of a `ClassCreator` or `InterfaceCreator` instance, which is then used to construct the type and its constituent members.
Normally, an in-line lambda expression is used for this argument, which creates a lexical structure which is similar to that of a type definition in Java.
By convention, the parameter name `cc` is typically used for the `ClassCreator` or `InterfaceCreator` instance.

The creator instance passed to the consumer may add or remove flags, set the access level, modify the class version, extend interfaces or a base class, and add members to the type.

//TEST:BEGIN
.Example of creating a simple class
[source,java]
----
import java.io.Serializable;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.ClassVersion;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class SimpleClassExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new class using the given lambda
        gizmo.class_("com.mycompany.SomeClass", cc -> {
            // we can implement interfaces
            cc.implements_(Serializable.class);
            // we can extend base classes
            cc.extends_(RuntimeException.class);
            // we can set flags
            cc.final_();
            // or...
            cc.addFlags(ModifierFlag.FINAL);
            // we can remove flags
            cc.removeFlag(ModifierFlag.SYNTHETIC);
            // we can set the access level
            cc.setAccess(AccessLevel.PACKAGE_PRIVATE);
            // or...
            cc.packagePrivate();
            // we can set the class version
            cc.setVersion(ClassVersion.V17);
        });
        // at this point, the class has been written to the output
    }
}
----
//TEST:END

//TEST:BEGIN
.Example of creating a simple interface
[source,java]
----
import java.io.Serializable;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.ClassVersion;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class SimpleInterfaceExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new interface using the given lambda
        gizmo.interface_("com.mycompany.SomeInterface", cc -> {
            // we can extend other interfaces
            cc.extends_(Serializable.class);
            cc.extends_(Cloneable.class);
            // we can set flags
            cc.addFlags(ModifierFlag.SYNTHETIC);
            // we can remove flags
            cc.removeFlag(ModifierFlag.SYNTHETIC);
            // we can set the access level
            cc.public_();
            // or...
            cc.setAccess(AccessLevel.PUBLIC);
            // we can set the class version
            cc.setVersion(ClassVersion.V17);
        });
    }
}
----
//TEST:END

[id=creating-fields]
== Creating fields

Fields may be added to types using the `field`, `staticField`, and `constantField` methods.
These methods accept a consumer for a `StaticFieldCreator` or `InstanceFieldCreator` instance.
The `field` method returns a <<fielddesc,`FieldDesc`>> for the newly created field.
The `staticField` and `constantField` methods return a <<fields,`StaticFieldVar`>> which may be used directly in expressions.

Fields may be initialized directly with a constant value at the time the field is defined by using the `setInitial` method.
For more complex initializers, the `setInitializer` method may be used, which accepts a <<blocks,code block creator>> which must yield a value for the field.
Initializers are automatically emitted into constructors or static initializers in the order that they are established.

By convention, the parameter name `fc` is typically used for the `FieldCreator` instance.

//TEST:BEGIN
.Example of creating a class with some fields
[source,java]
----
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ClassWithFieldsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new class using the given lambda
        gizmo.class_("com.mycompany.ClassWithFields", cc -> {
            // implicitly `int` because of the constant initializer
            cc.field("count", Const.of(123));
            // a more complex field
            cc.field("name", fc -> {
                fc.public_();
                fc.final_();
                fc.addFlag(ModifierFlag.TRANSIENT);
                // implicitly a `String` because of the initializer
                fc.setInitial("A more complex field");
            });
            // a field with a specified type and no initializer
            cc.field("problem", fc -> {
                fc.private_();
                fc.setType(Throwable.class);
            });
            // a public static final constant field
            cc.constantField("KIBI", Const.of(1024));
            // a regular static field
            cc.staticField("closed", fc -> {
                fc.volatile_();
                fc.setType(boolean.class);
            });
            // static fields may be final as well
            var nameArray = cc.staticField("nameArray", fc -> {
                fc.setType(String[].class);
                fc.final_();
                // initialize here or separately
            });
            // a more complex initializer example
            cc.field("namesAsList", fc -> {
                fc.setType(List.class);
                // blocks and expressions are covered elsewhere
                fc.setInitializer(b0 -> {
                    b0.yield(
                        b0.invokeStatic(
                            MethodDesc.of(Arrays.class, "asList", List.class, Object[].class),
                            b0.get(nameArray)
                        )
                    );
                });
            });
        });
    }
}
----
//TEST:END

[id=creating-methods]
== Creating methods and constructors

Methods and constructors are created using one of several methods on the type creator instance.
The method used depends on the properties of the constructor or method being built, and the kind of type that the method or constructor belongs to.
They are as follows:

* `staticMethod(...)` creates a static method on a class or interface
* `ClassCreator.method(...)` creates a concrete instance method on a class
* `ClassCreator.abstractMethod(...)` creates an abstract instance method on a class
* `ClassCreator.staticNativeMethod(...)` creates a static native method on a class
* `ClassCreator.nativeMethod(...)` creates an instance native method on a class
* `ClassCreator.constructor(...)` creates a constructor on a class
* `ClassCreator.defaultConstructor()` causes the default no-argument constructor to be generated
* `InterfaceCreator.method(...)` creates an abstract instance method on an interface
* `InterfaceCreator.defaultMethod(...)` creates a default instance method on an interface
* `InterfaceCreator.privateMethod(...)` creates a private instance method on an interface

In some cases, there may be an implicit modifier or access level that cannot be changed on that particular member.
For example, interface private methods are always `private`, and abstract methods are always `abstract`.
It is not possible to change these modifier flags or access levels.
See <<modifiers>> for more information.

The method and constructor factory methods generally follow three different forms:

* A form which accepts <<methoddesc,a descriptor>> plus a creator consumer
* A form which accepts a name plus a creator consumer
* A form which accepts a name and a <<methodtypedesc,type descriptor>> plus a creator consumer

Note that the constructor factory methods do not accept a name argument.

If the type is given (either by giving the constructor/method descriptor or by giving the type descriptor), then the constructor's or method's <<parameters,parameter definitions>> (if any) must conform to the type given; otherwise, an error will be produced when the constructor or method is defined.

If the type is not given, it will be computed based on the types of the parameter definitions (if any) plus the return type (which defaults to `void`, and which cannot be changed for constructors).

The following is an example of defining constructors and methods.
Note that constructors and some types of methods have bodies containing program code, which is covered in more detail in the <<blocks>> section, and other features such as <<annotations,annotations>> and <<modifiers,access levels and modifiers>> which are explained in their respective sections.

//TEST:BEGIN
.Example of defining constructors and methods
[source,java]
----
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.This;
import io.quarkus.gizmo2.creator.BlockCreator;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.desc.FieldDesc;
import io.quarkus.gizmo2.desc.MethodDesc;

public class TypesWithMethodsAndConstructorsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // an interface to implement
        ClassDesc nh = gizmo.interface_("org.numberifier.NumberHolder", cc -> {
            cc.method("incrementNumber", mc -> {
                mc.public_();
                mc.returning(int.class);
                // no body on interface method
            });
            cc.defaultMethod("setNumber", mc -> {
                ParamVar newNumber = mc.parameter("newNumber", int.class);
                // returns void by default; just return without doing anything
                mc.body(BlockCreator::return_);
            });
            cc.staticMethod("newInstance", mc -> {
                // return an instance of this interface
                mc.returning(cc.type());
                mc.public_();
                mc.body(b0 -> {
                    b0.return_(
                        b0.new_(ClassDesc.of("org.numberifier.NumberHolderImpl"))
);
                });
            });
        });

        // a base class to extend
        ClassDesc anh = gizmo.class_("org.numberifier.AbstractNumberHolder", cc -> {
            cc.implements_(nh);
            cc.abstract_();
            cc.abstractMethod("incrementNumber", mc -> {
                mc.addAnnotation(Override.class);
                mc.public_();
                mc.returning(void.class);
            });
        });

        // the leaf class
        gizmo.class_("org.numberifier.NumberHolderImpl", cc -> {
            cc.extends_(anh);
            // add some fields for context
            FieldDesc numberDesc = cc.field("number", Const.of(100));
            // add a default ctor
            cc.defaultConstructor();
            // we need this in order for our instance methods to do something interesting
            This this_ = cc.this_();
            // add a non-public ctor with an implicitly defined type
            cc.constructor(mc -> {
                mc.packagePrivate();
                ParamVar number = mc.parameter("number", int.class);
                mc.body(b0 -> {
                    b0.set(this_.field(numberDesc), number);
                    b0.return_();
                });
            });
            // method with implicitly defined type
            cc.method("incrementNumber", mc -> {
                mc.addAnnotation(Override.class);
                mc.public_();
                mc.returning(int.class);
                mc.body(b0 -> {
                    b0.inc(this_.field(numberDesc));
                    b0.return_(this_.field(numberDesc));
                });
            });
            // method with explicitly defined type
            cc.method("setNumber", MethodTypeDesc.of(
                ClassDesc.ofDescriptor("V"),
                ClassDesc.ofDescriptor("I")
            ), mc -> {
                mc.addAnnotation(Override.class);
                // parameters must match
                ParamVar newNumber = mc.parameter("newNumber");
                mc.body(b0 -> {
                    b0.set(this_.field(numberDesc), newNumber);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:END

Conventionally, we use `mc` as the name of the lambda parameter which accepts the method or constructor builder.
Since `cc` is conventionally used for classes, we use `mc` even for constructors.

[id=parameters]
=== Parameters

Methods and constructors may optionally accept parameters.
Parameters are declared using the `parameter(...)` method as shown in the example above.
The return value of the `parameter(...)` method is an object of type `ParamVar` which may be used as a variable (see <<local-vars>> for information about accessing variable values).

All parameters must be defined before defining the body of the method or constructor.
If the method or constructor was defined with a type, the defined parameters must match the number and type of parameters in the type.
Otherwise, the type of the method or constructor is derived from the parameters (and the return type, in the case of constructors).

[id=initializers]
=== Initializers

As a special case of constructors, static and instance initializers may be added to types as well.
Static initializers may be added to classes or interfaces using the `staticInitializer(...)` method.
Instance initializers only apply to classes, and may be defined using the `initializer(...)` method.

All defined static initializers and static field initializers are assembled into a single static initializer analogously to how the Java compiler does so, in order of definition.

Instance initializers and instance field initializers are all assembled into a single code block, which is then automatically replicated into each instance constructor.

[id=modifiers]
== Access levels and modifiers

Types, members, and variables in Java have an access level (specifically, `private`, package-private, `protected`, or `public`) as well as modifier flags (e.g. `volatile`, `final`, `synchronized`, etc.).

Access levels are represented using the `AccessLevel` enumeration.
Generally speaking, any type, member, or variable which is being built can have its access level set using the `setAccess(...)` method on its creator instance.
In most cases, there will also be convenience methods to set the valid access levels (`public_()`, `private_()`, etc.) which are equivalent to calling `setAccess(...)` with the corresponding access level as an argument.

Most things default to `PUBLIC`, other than (for example) fields or native methods, which generally default to `PRIVATE`.
The detailed breakdown of initial default modifiers is described <<default-modifiers,below>>.

Not every item supports every access level.
Attempting to set an access level which is not valid for the given target will result in an exception.
To determine if an access level is valid for the item, the `supports(...)` method may be used, passing in the `AccessLevel` as an argument.

Modifier flags are represented using the `ModifierFlag` enumeration.
Modifier flags may be added using the `addFlag(...)` method and removed using the `removeFlag(...)` method.

Like access levels, modifier flags are not always valid for every kind of creator.
Unlike access levels, there are some cases where a modifier flag is always present (for example, `static` when <<creating-methods,creating a static method>>).
Attempting to remove such flags will result in an exception; however, redundantly adding flags that are already present is allowed.
Likewise, removing a flag which it not allowed on the given type, member, or variable is always allowed.

The `ModifierLocation` enumeration lists all of the places where an access level or modifier flag may appear.
The constants in this enumeration may also be used to test whether a modifier is allowed or is forbidden on the corresponding location.

Any creator which accepts a modifier or access level extends the `ModifiableCreator` interface.
This interface can be used to determine the modifier location of the creator by way of the `modifierLocation()` method.
The `supports(...)` method can also be used to determine whether a modifier flag or access level may be used on that creator.

//TEST:BEGIN
.Example of access levels and modifier flags
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.BlockCreator;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class ModifiersAndAccessLevelsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("org.example.ModifiersAndAccessLevels", cc -> {
            // set the access level by enumeration
            cc.setAccess(AccessLevel.PACKAGE_PRIVATE);
            // or by direct method call
            cc.packagePrivate();
            // last one written "wins"
            cc.public_();
            // flags can be added by enumeration
            cc.addFlag(ModifierFlag.FINAL);
            // or by method call
            cc.final_();
            // flags can be removed even if they are not supported here
            cc.removeFlag(ModifierFlag.STATIC);
            cc.field("exampleField", fc -> {
                fc.setType(String.class);
                // set access by enumeration
                fc.setAccess(AccessLevel.PROTECTED);
                // or method call
                fc.protected_();
                // flags by enumeration
                fc.addFlag(ModifierFlag.TRANSIENT);
                // or call
                fc.volatile_();
            });

            cc.staticField("staticField", fc -> {
                fc.setType(int.class);
                fc.setInitial(12345);
                // set access
                fc.private_();
                // and flags
                fc.final_();
                // we can add redundant flags
                fc.addFlag(ModifierFlag.STATIC);
                // but we cannot remove them
            });

            cc.method("exampleMethod", mc -> {
                // add flag by enumeration
                mc.addFlag(ModifierFlag.BRIDGE);
                // or by method call
                mc.final_();
                // set access level by enumeration
                mc.setAccess(AccessLevel.PUBLIC);
                // or method call
                mc.public_();
                mc.parameter("aFinalInt", pc -> {
                    pc.setType(int.class);
                    // no access levels are supported on parameters!
                    /* pc.setAccess(xxx); */
                    // flags can be added to parameters
                    pc.addFlag(ModifierFlag.FINAL);
                    // by method call too
                    pc.final_();
                    // but note that "final" doesn't have any practical
                    // effect on parameters or local variables
                });
                // stub an empty body that returns nothing
                mc.body(BlockCreator::return_);
            });
        });
    }
}
----
//TEST:END

[id=default-modifiers]
=== Changing default access levels and modifiers

Instances of <<gizmo-interface,the `Gizmo` interface>> are configured with the set of default modifiers and access levels for the different `ModifierLocation` instances.
Instances of `Gizmo` are immutable; however, it is possible to create a derived `Gizmo` instance with a different configuration of default access levels and/or modifier flags using the `withDefaultModifiers` method.

//TEST:BEGIN
.Changing the default modifiers
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.creator.ModifierLocation;

public class DefaultModifiersExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // the `newGizmo` has updated defaults
        Gizmo newGizmo = gizmo.withDefaultModifiers(mc -> {
            // add the `synthetic` flag to all interfaces
            mc.add(ModifierLocation.INTERFACE, ModifierFlag.SYNTHETIC);
            // make all abstract methods be `protected`
            mc.set(ModifierLocation.CLASS_ABSTRACT_METHOD, AccessLevel.PROTECTED);
            // remove the `synthetic` flag from all classes
            mc.remove(ModifierLocation.CLASS, ModifierFlag.SYNTHETIC);
        });
    }
}
----
//TEST:END

By default, the following modifier flags and access levels are used if none is given:

[%header,cols=*]
|===
|Location|Access Level|Modifier Flags
|`INTERFACE_DEFAULT_METHOD`|`PUBLIC`|(none)
|`INTERFACE_PRIVATE_INSTANCE_METHOD`|`PRIVATE`|(none)
|`INTERFACE_ABSTRACT_METHOD`|`PUBLIC`|`ABSTRACT`
|`INTERFACE_STATIC_FIELD`|`PUBLIC`|`STATIC`
|`INTERFACE_STATIC_METHOD`|`PUBLIC`|`STATIC`
|`CLASS_CONSTRUCTOR`|`PUBLIC`|(none)
|`CLASS_INSTANCE_METHOD`|`PUBLIC`|(none)
|`CLASS_ABSTRACT_METHOD`|`PUBLIC`|`ABSTRACT`
|`CLASS_NATIVE_METHOD`|`PRIVATE`|(none)
|`CLASS_STATIC_METHOD`|`PUBLIC`|`STATIC`
|`CLASS_INSTANCE_FIELD`|`PRIVATE`|(none)
|`CLASS_STATIC_FIELD`|`PRIVATE`|`STATIC`
|`CLASS`|`PUBLIC`|`SYNTHETIC`
|`INTERFACE`|`PUBLIC`|`SYNTHETIC`, `ABSTRACT`
|`ANONYMOUS_CLASS`|`PRIVATE`|`SYNTHETIC`
|`PARAMETER`|(none)|(none)
|`LOCAL_VARIABLE`|(none)|(none)
|===

[id=blocks]
== Blocks

Blocks are created using instances of the `BlockCreator` interface.
This interface is not instantiated directly.
Rather, instances will be passed in to callbacks which build the block within contexts that require bytecode, such as initializers or method bodies.

Blocks are executed from the first instruction (top) to the last instruction of the block (bottom).
Normally, control leaves a block by falling through the bottom;
however, there are two main exceptions to this rule.
The first is when control is abruptly terminated (for example, a call to a method which throws an exception, or a `return_` within a nested conditional).
The second is certain control flow constructs, like <<if,`if_`>> or <<switch,`switch_`>>, where control flow might follow only one of several possible branches, and control would then resume with the next instruction after the control flow construct.

Additionally, there are some cases where control flow is _forbidden_ from falling through the bottom of the block.
Specifically, it is an error for the outermost block of a method or constructor to terminate in any way other than <<return,returning a value>> or <<throw,throwing an exception>>.

If Gizmo detects an instruction which is added to a block in an impossible-to-reach location (for example, immediately after a `return_`), an exception is thrown.
Use the `done()` method on `BlockCreator` to determine whether it has been terminated in cases where it cannot be easily known.

[id=scoping]
=== Scoping

In Gizmo 2, the code of methods and constructors is organized into lexically scoped _blocks_.
These scopes mirror the way that blocks are constructed by the API.
<<local-vars,Local variables>> are confined to the lexical scope in which they are declared.
<<parameters,Method and constructor parameters>> are always declared outside the outermost block, and thus they are accessible throughout the code of the method or constructor.

Since blocks are thus nested hierarchically, it is conventional to use the variable names `b0`, `b1`, `b2`, etc. to represent the nesting level.

//TEST:BEGIN
.Example of simple block nesting
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;

public class BlockNestingExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NestingExample", cc -> {
            cc.staticInitializer(b0 -> {
                // we're in the outermost block
                b0.block(b1 -> {
                    // this is a nested block
                    b1.block(b2 -> {
                        // nested even deeper
                    });
                });
            });
        });
    }
}
----
//TEST:END

[id=expressions]
== Expressions

Every operation yields an _expression_ which represents the result of that operation, represented by instances of the `Expr` interface.
Expressions may then be used as inputs to other operations.
Each expression has <<types,a type>> (which may be `void`).
Some expressions are also <<assignable,assignable>>, and some are <<constants,constants>>.
These expression types have special properties which are described below.

[id=expressions-use]
=== How to use expressions correctly

Expressions which are not <<constants,constants>> or <<assignable,variables>> may only be used once, and must be used in the same order in which they were created.
Gizmo _may_ make some minimal effort to order expressions correctly, however this should not be relied on.
Normally, correct ordering is a consequence of writing an expression in the natural way (left to right, innermost to outermost) so most of the time this is not a concern.
Violating this rule will result in an exception with a message like `Item is not at its expected location`.

A good rule of thumb is that if you ever create or extract a Java variable whose type is `Expr`, it should be stored into a <<local-vars,local variable>>.
Variables, like constants, can be used multiple times and in any position.

Here's an example:

//TEST:BEGIN
.Example of natural expression ordering
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;

public class NaturalOrderingExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NaturalOrdering", cc -> {
            cc.staticMethod("main", mc -> {
                mc.public_();
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // each arithmetic op yields an expression
                    b0.printf("The answer is: %d%n",
                        b0.add(
                            b0.mul(
                                Const.of(100),
                                Const.of(23)
                            ),
                            b0.div(
                                Const.of(512),
                                Const.of(8)
                            )
                        )
                    );
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN NaturalOrdering
//= The answer is: 2364
//TEST:END

[id=types]
=== Types

Every expression has a _type_.
The type of an expression is generally represented by a <<classdesc,`ClassDesc` descriptor>>.
The type may be primitive such as `int` or `boolean`, an object type like `java.lang.Object`, an array type like `int[]` or `java.lang.String[]`, or `void`.
Operations generally cannot use `void`-typed expressions as inputs.

In many cases, the type of operations can be _inferred_ based on their inputs.
In some cases, like method invocations or field accesses, the type of the expression is derived from the type of the member.
In other cases, the type must be specified explicitly.
In these cases, there will usually be an overloaded variation of the operation which accepts `Class<?>` instead of `ClassDesc` (or a list thereof).

The type of an expression can be queried using the `type()` method of `Expr` and other typed entities (which are all subtypes of `SimpleTyped`).

It is sometimes useful to categorize types as either being primitive or non-primitive.
This is done using the `typeKind()` method, which is also found on `SimpleTyped` and its subtypes, including `Expr`.
The return type of this method is `TypeKind`, an enumeration which contains constants for each of the eight primitive types, one for reference types, and one for `void`.

//TEST:BEGIN
.Examining types of a simple expression
[source,java]
----
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.TypeKind;

public class ExaminingTypesOfExpressions {
    public static void main(String[] args) {
        Const theConst = Const.of(true);
        ClassDesc type = theConst.type();
        TypeKind kind = theConst.typeKind();
        System.out.printf("The type and kind of the constant is: %s and %s%n", type.displayName(), kind);
    }
}
----
//TEST:OUTPUT
//= The type and kind of the constant is: boolean and BOOLEAN
//TEST:END

[id=constants]
=== Constants

A _constant_ is a simple expression whose value cannot change.
Most constants can be created once and reused as many times as needed.

[id=const]
==== The `Const` interface

The `Const` interface is used to represent expressions which are constant.
This interface also contains factory methods to create new constants, including (but not limited to):

* Primitive values (e.g. integers, booleans)
* `enum` constants (as <<jdk-const,`Constable`>> instances)
* Strings
* Classes (as `Class<?>` or as `ClassDesc`)
* `null`
* The value of a static final field
* Lists of other constants (as an immutable `List`)
* Maps of other constants (as an immutable `Map`)
* Other <<jdk-const,JDK constant types>> such as method handles or dynamic constants

[NOTE]
====
Be aware that list and map constants should only be used for relatively small numbers of entries.
While there is a theoretical limit of up to around 254 entries for these constants, it is advisable to keep the number of entries below 50 or so.
The maximum size of the class file constant pool (65,535 entries) creates a hard upper bound which can be hit easily when large collection constants are used, especially when each constant requires multiple constant table entries, which is sometimes the case.
====

It is also possible to create a constant for the default value of a given type using the `Const.ofDefault(...)` method.
The default value for a type is the value that would be assigned to a field of that type if no initializer is given (generally zero, `false`, or `null`).

[id=jdk-const]
==== The `ConstantDesc` and `Constable` interfaces

The JDK has the concept of classes which _are_ constants (such as primitive wrapper types, or `Class`) which implement the `ConstantDesc` interface in the `java.lang.constant` package, and classes which _may reduce to_ a constant (such as `enum` constants or `MethodHandle` instances) which implement the `Constable` interface.
Since constants are defined by the JVM specification, the `ConstantDesc` interface is sealed and thus can only be implemented in the JDK.

Any object of a class which implements either of these types may be used directly as a constant in Gizmo by way of `Const.of(...)` methods for those two types, or in certain cases, by way of method overloads which accept these types in addition to `Const` or `Expr`.

The `Constable` interface may be implemented by any class.
This provides a useful mechanism to allow objects to be serialized directly into class files (but also typically requires use of <<condy,dynamic constants>>, which is an advanced usage).
If a `Constable` is given to `Const.of(Constable)` which cannot be reduced to a constant, an exception is immediately thrown.

[id=condy]
==== Advanced use case: Dynamic constants

The JVM supports a special category of constants that cannot be directly accessed from programs written in Java source code called _dynamic constants_.
Dynamic constants are lazily initialized based on a _bootstrap method_ which computes the initial value of the constant.

Many kinds of useful dynamic constants are automatically created by the factory methods on `Const` without any special user intervention, including (but not limited to):

* `VarHandle` instances
* `Class` objects for primitive types
* `null` constants
* Method handles
* `enum` constants
* `List` and `Map` instances

To create other kinds of dynamic constants, the JDK class `DynamicConstantDesc` in the `java.lang.constant` package may be used through the `Const.of(ConstantDesc)` method described above.
For more information, see the JDK documentation for that class.

[NOTE]
====
The JVM specification does not guarantee that dynamic constants are only initialized one time.
In practical terms, this means that two threads which happen upon an uninitialized dynamic constant may simultaneously initialize it, possibly causing one thread to resolve an "ephemeral" value which is not seen after the constant is initialized.
Therefore, dynamic constants which return objects should not rely on _identity comparison_; since even something as simple as `eq(myConst, myConst)` is allowed to return `false` in this case.
====

[id=this]
=== The special `this` expression

It is common to need access to the _receiver object_, which in Java is referenced by the `this` keyword.
The `this_()` method may be used on a class or interface creator to yield an expression whose type is `This`, which may be used within instance methods, constructors, and initializers to refer to the receiver object.
The resultant expression may not be used from a static context (such as a static method or initializer); such usages will result in an exception.

By convention, it is typical to call `this_()` once near the top of your class builder lambda, and reuse the same instance.
Calling `this_()` multiple times is not harmful, however.

//TEST:BEGIN
.Example of accessing `this`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Expr;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.This;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ThisAccessExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("ThisAccess", cc -> {
            // get "this" where it can be used by all members
            This this_ = cc.this_();
            cc.defaultConstructor();
            MethodDesc showThis = cc.method("showThis", mc -> {
                mc.body(b0 -> {
                    b0.printf("This is %s%n", this_);
                    b0.return_();
                });
            });
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    Expr instance = b0.new_(cc.type());
                    b0.invokeVirtual(showThis, instance);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN ThisAccess
//~ This is ThisAccess.*
//TEST:END

[id=assignable]
=== Assignable expressions

Some expressions are _assignable_, which means that in addition to being usable as inputs for operations, they also may be written to or modified so that subsequent uses will see the modified value.

[id=local-vars]
==== Local variables

Local variables may be defined within any <<blocks,block>> using the `localVar(...)` method.
Every local variable must have a name (as a `String`) and an initial value.
Local variable values are observable in debuggers when single-stepping through programs.

Note that unlike the Java language, local variables in Gizmo must be explicitly initialized; thus, in most cases it is better to define them later rather than earlier.
This does not incur any performance penalty at run time; on the contrary, it allows Gizmo to emit only a single local variable table entry per variable.

Once defined, a local variable can be referenced or updated as many times as needed within the <<scoping,scope>> in which it was defined (or a nested scope thereof).

By convention, the `LocalVar` variable's name matches the name given to `localVar(...)`.
This is strongly encouraged for readability.

//TEST:BEGIN
.Local variable example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;

public class LocalVarExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("LocalVar", cc -> {
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar one = b0.localVar("one", 1);
                    b0.block(b1 -> {
                        LocalVar two = b1.localVar("two", "Two");
                        b1.printf("One is %d and two is %s%n", one, two);
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN LocalVar
//= One is 1 and two is Two
//TEST:END

[id=fields]
==== Field expressions

[id=array-elements]
==== Array element expressions

[id=variable-mutate]
==== Mutating assignable expressions

There are several operations which can be used to mutate assignable expressions.
Note that `final` variables generally cannot be mutated outside of initialization.

===== `set(...)`

The `set(...)` method on the `BlockCreator` interface may be used to modify the value of an assignable expression.
This is equivalent to using the assignment (`=`) operator in Java.

//TEST:BEGIN
.Variable mutation using `set(...)`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;

public class SetExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Set", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // replace the `args` parameter variable value
                    b0.set(args, b0.newArray(String.class, Const.of("Hello!")));
                    b0.printf("I changed args to %s%n", b0.arrayToString(args));
                    // now change just element 0
                    b0.set(args.elem(0), "New string!");
                    b0.printf("I changed args[0] to %s%n", args.elem(0));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Set
//= I changed args to [Hello!]
//= I changed args[0] to New string!
//TEST:END

[id=swap]
===== `swap`

The `swap(...)` method exchanges values between two assignable expressions without using a temporary variable.
This operation can not be <<variable-atomics,atomic>> because it acts on two separate memory locations.

//TEST:BEGIN
.Swapping variable values using `swap(...)`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.This;
import io.quarkus.gizmo2.desc.FieldDesc;

public class SwapExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Pet", cc -> {
            cc.defaultConstructor();
            This this_ = cc.this_();
            FieldDesc name = cc.field("name", fc -> {
                fc.setType(String.class);
                fc.private_();
            });
            // fluent style accessors
            cc.method("name", mc -> {
                mc.returning(String.class);
                mc.body(b0 -> b0.return_(this_.field(name)));
            });
            cc.method("name", mc -> {
                ParamVar newName = mc.parameter("newName", String.class);
                mc.returning(String.class);
                mc.body(b0 -> {
                    b0.swap(this_.field(name), newName);
                    // now `newName` contains the old name
                    b0.return_(newName);
                });
            });
        });
    }
}
----
//TEST:END

[id=rotate]
===== `rotate`

The `rotate(...)` method moves all the values given as arguments one position to the right, and the rightmost value to the leftmost position, without requiring an intermediate temporary variable.
This operation can not be <<variable-atomics,atomic>> because it acts on multiple memory locations.

//TEST:BEGIN
.Rotating variable values using `rotate(...)`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;

public class RotateExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Rotate", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.ne(args.length(), 4), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected 4 arguments");
                    });
                    b0.printf("The initial order is: %s %s %s %s%n",
                        args.elem(0),
                        args.elem(1),
                        args.elem(2),
                        args.elem(3)
                    );
                    b0.rotate(args.elem(0), args.elem(1), args.elem(2), args.elem(3));
                    b0.printf("The new order is: %s %s %s %s%n",
                        args.elem(0),
                        args.elem(1),
                        args.elem(2),
                        args.elem(3)
                    );
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Rotate a b c d
//= The initial order is: a b c d
//= The new order is: d a b c
//TEST:END

[id=arith-assign]
===== Arithmetic assignment operators

In Java, the `+=`, `-=`, `*=`, `/=`, and `%=` operators may be used to perform an <<arithmetic,arithmetic operation>> on a variable and a value, and assign the result back to the variable.
The `BlockCreator` interface has corresponding methods for each of these operations: `addAssign`, `subAssign`, `mulAssign`, `divAssign`, and `remAssign`.
Each of these methods accepts the assignable expression and the value to operate on.

//TEST:BEGIN
.Arithmetic assignment example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ArithmeticAssignmentExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class, "parseInt", int.class, String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("ArithmeticAssignment", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.lt(args.length(), 1), b1 ->
                        b1.throw_(IllegalArgumentException.class, "Expected 1 argument"));
                    LocalVar n = b0.localVar("n", b0.invokeStatic(parseInt, args.elem(0)));
                    b0.printf("n = %d%n", n);
                    b0.addAssign(n, Const.of(10));
                    b0.printf("+ 10 = %d%n", n);
                    b0.subAssign(n, Const.of(5));
                    b0.printf("- 5 = %d%n", n);
                    b0.mulAssign(n, Const.of(4));
                    b0.printf("* 4 = %d%n", n);
                    b0.divAssign(n, Const.of(2));
                    b0.printf("/ 2 = %d%n", n);
                    b0.remAssign(n, Const.of(17));
                    b0.printf("%% 17 = %d%n", n);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN ArithmeticAssignment 3
//= n = 3
//= + 10 = 13
//= - 5 = 8
//= * 4 = 32
//= / 2 = 16
//= % 17 = 16
//TEST:END

[id=inc-and-dec]
===== Increment and decrement

If the amount being added to or subtracted from a value is <<constants,constant>>, the `inc(...)` and `dec(...)` methods on `BlockCreator` may be used.
In certain cases, this may generate more compact method bodies.
For <<loop,loops>> in particular, this can aid readability.

//TEST:BEGIN
.Increment and decrement example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Expr;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class IncDecExample {
    private static final MethodDesc isLetter = MethodDesc.of(
        Character.class, "isLetter", boolean.class, char.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("IncDec", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.lt(args.length(), 1), b1 ->
                        b1.throw_(IllegalArgumentException.class, "Expected 1 argument"));
                    LocalVar i = b0.localVar("i", 0);
                    LocalVar str = b0.localVar("str", args.elem(0));
                    LocalVar len = b0.localVar("len", b0.withString(str).length());
                    LocalVar letters = b0.localVar("letters", 0);
                    LocalVar nonLetters = b0.localVar("nonLetters", len);
                    b0.while_(b1 -> b1.yield(b1.lt(i, len)), b1 -> {
                        Expr ch = b1.withString(str).charAt(i);
                        b1.if_(b1.invokeStatic(isLetter, ch), b2 -> {
                            b2.inc(letters);
                            b2.dec(nonLetters);
                        });
                        // next character
                        b1.inc(i);
                    });
                    b0.printf("The string has %d letters and %d non-letters%n", letters, nonLetters);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN IncDec foobar
//= The string has 6 letters and 0 non-letters
//TEST:RUN IncDec foo-bar_baz#quux
//= The string has 13 letters and 3 non-letters
//TEST:RUN IncDec ===
//= The string has 0 letters and 3 non-letters
//TEST:END

[id=bitwise-assign]
===== Bitwise assignment operators

Corresponding to Java's <<bitwise-logic,bitwise>> assignment operators, specifically `&=`, `|=`, and `^=`, and <<bitwise-shift,shift>> operators `<\<=`, `>>=`, and `>>>=`, there are methods on `BlockCreator` to implement these operations. They are `andAssign(...)`, `orAssign(...)`, `xorAssign(...)`, `shlAssign(...)`, `shrAssign(...)`, and `ushrAssign(...)`.

Like the <<arith-assign,arithmetic assignment operators>>, these methods accept an <<assignable,assignable expression>> along with a value which may be any expression.

//TEST:BEGIN
.Example of bitwise assignment operations
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class BitwiseAssignmentExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class, "parseInt", int.class, String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("BitwiseAssignment", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.lt(args.length(), 1), b1 ->
                        b1.throw_(IllegalArgumentException.class, "Expected 1 argument"));
                    LocalVar n = b0.localVar("n", b0.invokeStatic(parseInt, args.elem(0)));
                    // pass `n` through a gauntlet of various bitwise operations
                    b0.printf("n = 0x%x%n", n);
                    b0.andAssign(n, Const.of(0x5555));
                    b0.printf(" & 0x5555 = 0x%x%n", n);
                    b0.orAssign(n, Const.of(0xa0a0));
                    b0.printf(" | 0xa0a0 = 0x%x%n", n);
                    b0.xorAssign(n, Const.of(0x9999));
                    b0.printf(" ^ 0x9999 = 0x%x%n", n);
                    b0.shlAssign(n, Const.of(16));
                    b0.printf(" << 16 = 0x%x%n", n);
                    b0.shrAssign(n, Const.of(8));
                    b0.printf(" >> 8 = 0x%x%n", n);
                    b0.ushrAssign(n, Const.of(8));
                    b0.printf(" >>> 8 = 0x%x%n", n);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN BitwiseAssignment 13
//= n = 0xd
//= & 0x5555 = 0x5
//= | 0xa0a0 = 0xa0a5
//= ^ 0x9999 = 0x393c
//= << 16 = 0x393c0000
//= >> 8 = 0x393c00
//= >>> 8 = 0x393c
//TEST:END

[id=variable-atomics]
==== Advanced use case: Atomic operations on variables

To perform atomic operations on variables in Java, a `VarHandle` is generally used.
The type of `VarHandle`, and the means of acquiring it, vary depending on what is being accessed.

Gizmo provides methods to perform atomic variable operations on any <<assignable,assignable expression>>, managing the `VarHandle` automatically behind the scenes as a <<condy,dynamic constant>>.

The basic operations `get(...)` and `set(...)` also have variations which accept an atomic <<memory-orders,memory order>>, which allows for memory access semantics which differ from that on the variable's declaration (if any).

There are operations for atomic get-and-set (`getAndSet(...)`) and get-modify-set (`getAndAdd(...)`, `getAndBitwiseAnd(...)`, `getAndBitwiseOr(...)`, and `getAndBitwiseXor(...)`), which accept an assignable expression, an argument, and an optional <<memory-orders,memory order>> which defaults to `Volatile` if not given.

The last group of atomic operations are compare-and-set (`compareAndSet(...)` and `weakCompareAndSet(...)`) and compare-and-exchange (`compareAndExchange(...)`).
These operations accept an assignable expression, an expected value, and an update value.
The `compareAndSet(...)` and `weakCompareAndSet(...)` methods return a `boolean`-typed expression that is `true` if the exchange succeeded or `false` if it did not succeed.
The `compareAndExchange(...)` methods return a "witness" value that was observed before the operation.
If the witness value is equal to the expected value, then the exchange has succeeded.
Additionally, the `weakCompareAndSet(...)` and `compareAndExchange(...)` methods optionally accept a <<memory-orders,memory order>> argument which defaults to `Volatile` if not given.

[id=memory-orders]
===== Memory orders

The memory order for atomic operations are defined by the JVM specification.
Choosing a memory order for an operation in Gizmo is done using values from the `MemoryOrder` enumeration.

The values of this enumeration are `Plain`, `Opaque`, `Acquire`, `Release`, and `Volatile`, and the special mode `AsDeclared`, which will use `Plain` unless the variable being operated on was declared `volatile`, in which case `Volatile` is used.

[id=void-expr]
=== Void expressions

Some expressions may be `void`-typed (for instance, a method call to a `void`-returning method).
Most operations will not accept a `void`-typed value, however they may be useful in certain circumstances.
Returning the `void` constant (`return_(Const.ofVoid())`) is the same as a no-argument `return` (`return_()`).
This means that it is always safe to directly return the result of a method invocation, as long as the callee method's return type is the same as the calling method's return type (even if it is `void`).

[id=yielding]
=== Yielding values from blocks

Sometimes, a block is treated like an expression, like the conditional part of an `if_`, or a `case_` of a `switch_` expression.
In these cases, the block must yield a value upon exit.
This can be done using the `yield(...)` method on `BlockCreator`.

If a block has a non-`void` output type, and control leaves the bottom of the block without a `yield(...)`, an exception will be thrown.

Blocks which are not treated like expressions generally have a type of `void`.
It is permissible to yield the `void` constant (`Const.ofVoid()`) from these blocks, but it is not necessary to do so.

[id=arithmetic]
=== Arithmetic expressions

There are methods for each arithmetic operation supported by the JVM.
Many of the methods for arithmetic operations have convenience overloads which accept primitive or object values for one argument.
Internally, these methods will automatically wrap this argument with a constant.

If an arithmetic operation is combined with assignment (e.g. `foo = foo + 9`), then <<arith-assign,arithmetic assignment>> should be used instead.

Both inputs of a binary arithmetic operation must be of the same type.
If the types differ, then Java-like widening and unboxing rules are applied if possible.
If these rules fail, then an exception is thrown at the point where the expression is created.

[id=add]
==== `add`

The `add(...)` operation adds two integers or floating-point numbers.
The Java language equivalent of the `add(...)` operation is the binary `+` operator (when applied to integers and floating-point numbers only).

//TEST:BEGIN
.Example of `add`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class AddFloatExample {
    private static final MethodDesc parseFloat = MethodDesc.of(
        Float.class,
        "parseFloat",
        float.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("AddFloat", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar f1 = b0.localVar("f1", b0.invokeStatic(parseFloat, args.elem(0)));
                    LocalVar f2 = b0.localVar("f2", b0.invokeStatic(parseFloat, args.elem(1)));
                    b0.printf("%.2f + %.2f = %.2f%n", f1, f2, b0.add(f1, f2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN AddFloat 3 5
//= 3.00 + 5.00 = 8.00
//TEST:END

[id=sub]
==== `sub`

The `sub(...)` operation subtracts two integers or floating-point numbers.
The Java language equivalent of the `sub(...)` operation is the binary `-` operator.

//TEST:BEGIN
.Example of `sub`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class SubLongExample {
    private static final MethodDesc parseLong = MethodDesc.of(
        Long.class,
        "parseLong",
        long.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("SubLong", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar l1 = b0.localVar("l1", b0.invokeStatic(parseLong, args.elem(0)));
                    LocalVar l2 = b0.localVar("l2", b0.invokeStatic(parseLong, args.elem(1)));
                    b0.printf("%d - %d = %d%n", l1, l2, b0.sub(l1, l2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN SubLong 8 5
//= 8 - 5 = 3
//TEST:END

[id=mul]
==== `mul`

The `mul(...)` operation multiplies two integers or floating-point numbers.
The Java language equivalent of the `mul(...)` operation is the `*` operator.

//TEST:BEGIN
.Example of `mul`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class MulIntExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("MulInt", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%d * %d = %d%n", i1, i2, b0.mul(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN MulInt 3 5
//= 3 * 5 = 15
//TEST:END

[id=div]
==== `div`

The `div(...)` operation divides two integers or floating-point numbers.
The Java language equivalent of the `div(...)` operation is the `/` operator.
Note that integer division will fail with an exception if the second argument is equal to zero.

//TEST:BEGIN
.Example of `div`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class DivIntExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("DivInt", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%d / %d = %d%n", i1, i2, b0.div(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN DivInt 15 5
//= 15 / 5 = 3
//TEST:END

[id=rem]
==== `rem`

The `rem(...)` operation performs a remainder operation of two integers or floating-point numbers.
The Java language equivalent of the `rem(...)` operation is the `%` operator.
Note that integer division (including the remainder operation) will fail with an exception if the second argument is equal to zero.

//TEST:BEGIN
.Example of `rem`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class RemIntExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("RemInt", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%d %% %d = %d%n", i1, i2, b0.rem(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN RemInt 15 12
//= 15 % 12 = 3
//TEST:END

[id=neg]
==== `neg`

The unary `neg(...)` operation performs a negation of its integer or floating-point argument.
The Java language equivalent of the `neg(...)` operation is the unary `-` operator.

//TEST:BEGIN
.Example of `neg`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class NegDoubleExample {
    private static final MethodDesc parseDouble = MethodDesc.of(
        Double.class,
        "parseDouble",
        double.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NegDouble", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 1), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected one argument");
                    });
                    LocalVar d = b0.localVar("d", b0.invokeStatic(parseDouble, args.elem(0)));
                    b0.printf("negated %.2f = %.2f%n", d, b0.neg(d));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN NegDouble 2
//= negated 2.00 = -2.00
//TEST:RUN NegDouble -4
//= negated -4.00 = 4.00
//TEST:END

[id=bitwise-logic]
=== Bitwise logical expressions

There are methods for each bitwise logical operation supported by the JVM.
These operations generally only support integer types.
Many of the methods for bitwise operations have convenience overloads which accept primitive or object values for one argument.
Internally, these methods will automatically wrap this argument with a constant.

If a bitwise logical operation is combined with assignment (e.g. `foo = foo & 0x1F`), then <<bitwise-assign,bitwise assignment>> should be used instead.

Both inputs of a binary bitwise logical operation must be of the same type.
If the types differ, then Java-like widening and unboxing rules are applied if possible.
If these rules fail, then an exception is thrown at the point where the expression is created.

[id=and]
==== `and`

The `and(...)` operation performs a bitwise-AND on the two arguments, returning the result.
The Java language equivalent of this operation is the `&` operator.

//TEST:BEGIN
.Example of bitwise `and`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class AndIntExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("AndInt", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%d & %d = %d%n", i1, i2, b0.and(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN AndInt 5 6
//= 5 & 6 = 4
//TEST:END

[id=or]
==== `or`

The `or(...)` operation performs a bitwise-OR on the two arguments, returning the result.
The Java language equivalent of this operation is the `|` operator.

//TEST:BEGIN
.Example of bitwise `or`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class OrIntExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("OrInt", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%d | %d = %d%n", i1, i2, b0.or(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN OrInt 1 2
//= 1 | 2 = 3
//TEST:END

[id=xor]
==== `xor`

The `xor(...)` operation performs a bitwise-XOR on the two arguments, returning the result.
The Java language equivalent of this operation is the `^` operator.

//TEST:BEGIN
.Example of bitwise `xor`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class XorIntExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("XorInt", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%d ^ %d = %d%n", i1, i2, b0.xor(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN XorInt 2 4
//= 2 ^ 4 = 6
//TEST:END

[id=complement]
==== `complement`

The `complement(...)` operation performs a unary bitwise-complement on the sole argument, returning the result.
The Java language equivalent of this operation is the unary `~` operator.

//TEST:BEGIN
.Example of bitwise `complement`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ComplementLongExample {
    private static final MethodDesc parseLong = MethodDesc.of(
        Long.class,
        "parseLong",
        long.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("ComplementLong", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 1), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected one argument");
                    });
                    LocalVar i = b0.localVar("i", b0.invokeStatic(parseLong, args.elem(0)));
                    b0.printf("complement of %1$d (0x%1$x) = %2$d (0x%2$x)%n", i, b0.complement(i));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN ComplementLong 5
//= complement of 5 (0x5) = -6 (0xfffffffffffffffa)
//TEST:END

[id=bitwise-shift]
=== Bitwise shifting expressions

The JVM supports three bit-shifting operations on integers.
There is an equivalent method for each.
The shift methods have overloads which accept an integer value for one argument.
Internally, these overloads will wrap the argument with a constant.

If a bitwise shift operation is combined with assignment (e.g. `foo = foo >> 4`), then <<bitwise-assign,bitwise assignment>> should be used instead.

[id=shl]
==== `shl`

The `shl(...)` operation shifts the bits of the integer given in the first argument leftwards (towards the MSB) by the number of bits given in the integer second argument.
New incoming low-order bits are filled with zero.
As per the JVM specification, the second argument is implicitly bitwise-ANDed with an integer equal to the number of bits in the type of the first argument minus one (so, 31 for `int` and 63 for `long`).
This prevents shifting by any effective distance which is greater than this number or less than zero.

//TEST:BEGIN
.Example of `shl`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ShlExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Shl", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%1$d (0x%1$x) << %2$d (0x%2$x) = %3$d (0x%3$x)%n", i1, i2, b0.shl(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Shl 2 4
//= 2 (0x2) << 4 (0x4) = 32 (0x20)
//TEST:END

[id=shr]
==== `shr`

The `shr(...)` operation shifts the bits of the integer given in the first argument rightwards (towards the LSB) by the number of bits given in the integer second argument.
New incoming high-order bits are equal to the MSB of the first argument (i.e. sign-extended).
As per the JVM specification, the second argument is implicitly bitwise-ANDed with an integer equal to the number of bits in the type of the first argument minus one (so, 31 for `int` and 63 for `long`).
This prevents shifting by any effective distance which is greater than this number or less than zero.

//TEST:BEGIN
.Example of `shr`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ShrExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Shr", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%1$d (0x%1$x) >> %2$d (0x%2$x) = %3$d (0x%3$x)%n", i1, i2, b0.shr(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Shr 32 3
//= 32 (0x20) >> 3 (0x3) = 4 (0x4)
//TEST:END

[id=ushr]
==== `ushr`

The `ushr(...)` operation shifts the bits of the integer given in the first argument rightwards (towards the LSB) by the number of bits given in the integer second argument.
New incoming high-order bits are filled with zero.
As per the JVM specification, the second argument is implicitly bitwise-ANDed with an integer equal to the number of bits in the type of the first argument minus one (so, 31 for `int` and 63 for `long`).
This prevents shifting by any effective distance which is greater than this number or less than zero.

//TEST:BEGIN
.Example of `ushr`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class UshrExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Ushr", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar i1 = b0.localVar("i1", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar i2 = b0.localVar("i2", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.printf("%1$d (0x%1$x) >>> %2$d (0x%2$x) = %3$d (0x%3$x)%n", i1, i2, b0.ushr(i1, i2));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Ushr 32 3
//= 32 (0x20) >>> 3 (0x3) = 4 (0x4)
//TEST:END

[id=relational]
=== Relational expressions

The JVM combines most relational expressions directly into conditional constructs.
However, this can be confusing for users who are familiar with the Java language but less familiar with JVM bytecode.
Gizmo separates the two concepts, creating operators for various relational expressions which work with any conditional control construct (e.g. `if_`, `ifNot`, `ifElse`, `cond`).

[id=equality]
==== Equality operators: `eq`, `ne`

The equality/inequality operators are implemented using the `eq(...)` and `ne(...)` methods, which return a boolean expression that contains the result of the comparison.
The corresponding Java operators (`==` and `!=`) have differing behavior depending on whether the inputs are of integer, floating-point, or object type.

Both inputs of an equality/inequality operation must be of the same type.
If the types differ, then Java-like widening and unboxing rules are applied if possible.
If these rules fail, then an exception is thrown at the point where the expression is created.

//TEST:BEGIN
.Example of `eq` and `ne`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class EqNeExample {
    private static final MethodDesc parseInt = MethodDesc.of(
        Integer.class,
        "parseInt",
        int.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("EqNe", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.ne(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected two arguments");
                    });
                    LocalVar a = b0.localVar("a", b0.invokeStatic(parseInt, args.elem(0)));
                    LocalVar b = b0.localVar("b", b0.invokeStatic(parseInt, args.elem(1)));
                    b0.ifElse(b0.eq(a, b), b1 -> {
                        b1.printf("%d == %d%n", a, b);
                    }, b1 -> {
                        b1.printf("%d != %d%n", a, b);
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN EqNe 1 2
//= 1 != 2
//TEST:RUN EqNe 1 1
//= 1 == 1
//TEST:END

[id=ordering-operators]
==== Ordering operators: `lt`, `le`, `gt`, `ge`

The Java ordering operators `<`, `\<=`, `>`, and `>=` are implemented in Gizmo using the `lt(...)`, `le(...)`, `gt(...)`, and `ge(...)` operations, respectively.
For primitive floating-point and integer types, these operations work in the same manner as their Java counterparts.

Additionally, Gizmo supports using these operations on object-typed values which statically implement the `Comparable` interface.
If the static type of the given object values does not implement this interface, then verification of the method bytecode will fail.

//TEST:BEGIN
.Example of ordering operations
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class SortExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Sort", cc -> {
            MethodDesc partition = cc.staticMethod("partition", mc -> {
                mc.private_();
                ParamVar array = mc.parameter("array", String[].class);
                ParamVar lo = mc.parameter("lo", int.class);
                ParamVar hi = mc.parameter("hi", int.class);
                mc.returning(int.class);
                mc.body(b0 -> {
                    LocalVar pivot = b0.localVar("pivot", array.elem(hi));
                    LocalVar i = b0.localVar("i", b0.sub(lo, 1));
                    LocalVar j = b0.localVar("j", lo);
                    b0.while_(b1 -> {
                        b1.yield(b1.lt(j, hi));
                    }, b1 -> {
                        b1.if_(b1.le(array.elem(j), pivot), b2 -> {
                            b2.inc(i);
                            b2.swap(array.elem(i), array.elem(j));
                        });
                        b1.inc(j);
                    });
                    b0.inc(i);
                    b0.swap(array.elem(i), array.elem(hi));
                    b0.return_(i);
                });
            });
            MethodDesc quicksort = cc.staticMethod("quicksort", mc -> {
                mc.private_();
                ParamVar array = mc.parameter("array", String[].class);
                ParamVar lo = mc.parameter("lo", int.class);
                ParamVar hi = mc.parameter("hi", int.class);
                mc.body(b0 -> {
                    b0.if_(b0.lt(lo, hi), b1 -> {
                        LocalVar partIdx = b1.localVar("partIdx", b1.invokeStatic(partition, array, lo, hi));
                        // self-recursion
                        b1.invokeStatic(mc.desc(), array, lo, b1.sub(partIdx, 1));
                        b1.invokeStatic(mc.desc(), array, b1.add(partIdx, 1), hi);
                    });
                    b0.return_();
                });
            });
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // sort the arguments
                    b0.invokeStatic(quicksort, args, Const.of(0), b0.sub(args.length(), 1));
                    b0.forEach(args, (b1, item) -> {
                        b1.printf("%s%n", item);
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Sort d a c e b
//= a
//= b
//= c
//= d
//= e
//TEST:END

[id=comparator-like]
==== Comparator-like operations: `cmp`, `cmpl`, `cmpg`

Some binary comparison operations return a three-state result.
For these operations, the two inputs are evaluated and a result is returned based on the relationship between the two values.
These operations return a value which is less than or equal to `-1` if the first value is less than the second, exactly `0` if the two values are equal, or a value which is greater than or equal to `1` if the first value is greater than the second.
The `cmp`, `cmpl`, and `cmpg` operations will operate on any integer or floating-point value, and any object value whose class implements `Comparable`.
Using any of these operations on an object whose class does not implement `Comparable` will cause a verification error at run time.

These operations all behave identically to one another, except for how `NaN` and signed-zero values are handled for floating-point numbers.

For floating-point numbers, the `cmp` operation treats `NaN` as being greater than all other numbers, and `-0.0` as being less than `0.0`.
The `cmpg` operation will return `1` if either operand is `NaN`, and the `cmpl` operation will return `0` if either operand is `NaN`.
Both `cmpl` and `cmpg` treat `-0.0` as being equal to `0.0`.

[id=invocation]
=== Invocation expressions

Invocation expressions are used to call other methods or constructors.
They all take a <<methoddesc,method or constructor descriptor>> representing the method or constructor to invoke.
For instance invocations, a receiver instance object is also required.
For all invocations, type of the invocation expression is equal to the return type of the <<methodtypedesc,method's type descriptor>> (which is always `void` if the callee is a constructor).

[id=invoke-static]
==== `invokeStatic`

The `invokeStatic` operation calls a `static` method on a class or interface.

//TEST:BEGIN
.Example of `invokeStatic`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class InvokeStaticExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("InvokeStatic", cc -> {
            MethodDesc sayHello = cc.staticMethod("sayHello", mc -> {
                mc.private_();
                ParamVar name = mc.parameter("name", String.class);
                mc.body(b0 -> {
                    b0.printf("Hello, %s!%n", name);
                    b0.return_();
                });
            });
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // invoke the static method
                    b0.invokeStatic(sayHello, Const.of("User"));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN InvokeStatic
//= Hello, User!
//TEST:END

[id=invoke-virtual]
==== `invokeVirtual`

The `invokeVirtual` operation calls an instance method on a class using _virtual dispatch_, or to invoke `private` methods on a class or interface within the same _nest_ as the caller.
While it can also be used to invoke public methods on an interface instance in many cases, it is generally a better practice to use <<invoke-interface,`invokeInterface`>> instead for that purpose.

The class of the method which is called is determined by the class of the receiver object.

//TEST:BEGIN
.Example of `invokeVirtual`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.ConstructorDesc;
import io.quarkus.gizmo2.desc.MethodDesc;

public class InvokeVirtualExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("InvokeVirtual", cc -> {
            // create a default constructor so we can have an instance
            ConstructorDesc ctor = cc.defaultConstructor();
            MethodDesc sayHello = cc.method("sayHello", mc -> {
                mc.private_();
                ParamVar name = mc.parameter("name", String.class);
                mc.body(b0 -> {
                    b0.printf("Hello, %s!%n", name);
                    b0.return_();
                });
            });
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // invoke the virtual method on an instance that we create
                    b0.invokeVirtual(sayHello, b0.new_(ctor), Const.of("User"));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN InvokeVirtual
//= Hello, User!
//TEST:END

[id=invoke-interface]
==== `invokeInterface`

The `invokeInterface` operation calls an instance method on an interface using _interface dispatch_.

The class of the method which is called is determined by the class of the receiver object.

//TEST:BEGIN
.Example of `invokeInterface`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.ConstructorDesc;
import io.quarkus.gizmo2.desc.MethodDesc;

public class InvokeInterfaceExample {
    private static final MethodDesc length = MethodDesc.of(CharSequence.class, "length", int.class);

    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("InvokeInterface", cc -> {
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    Const str = Const.of("a few words");
                    b0.printf("The length of \"%s\" is %d%n", str,
                        b0.invokeInterface(length, str));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN InvokeInterface
//= The length of "a few words" is 11
//TEST:END

[id=invoke-special]
==== `invokeSpecial`

The `invokeSpecial` operation calls an instance method or constructor on the current class or interface, or on a supertype of the current class or interface, without virtual dispatch.

Constructors are required to call another constructor of the current type or a constructor of the immediate supertype using `invokeSpecial` before performing any operations which may mutate or leak <<this,`this_()`>>.

When calling methods, the `invokeSpecial` operation should only be used for method calls when calling a method directly present on the current type or a supertype of the current type to prevent virtual dispatch.
For all other cases, including invocation of instance methods declared `private` or `final`, `invokevirtual` should be used instead.

//TEST:BEGIN
.Example of `invokeSpecial`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.This;
import io.quarkus.gizmo2.desc.ConstructorDesc;
import io.quarkus.gizmo2.desc.MethodDesc;

public class InvokeSpecialExample {
    private static final MethodDesc objectToString = MethodDesc.of(Object.class, "toString", String.class);

    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("InvokeSpecial", cc -> {
            This this_ = cc.this_();
            // tip: we can create this constructor via cc.defaultConstructor()
            cc.constructor(mc -> {
                mc.body(b0 -> {
                    // use `invokeSpecial` to call Object()
                    b0.invokeSpecial(ConstructorDesc.of(Object.class), this_);
                    b0.return_();
                });
            });

            cc.method(objectToString, mc -> {
                // not necessary, but illustrative
                mc.addAnnotation(Override.class);
                // we don't need to redeclare the return type because the descriptor already has it
                mc.body(b0 -> {
                    b0.throw_(RuntimeException.class, "Called the wrong toString()");
                });
            });

            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // call super.toString() on a new instance
                    b0.printf("super.toString() == \"%s\"",
                        b0.invokeSpecial(objectToString, b0.new_(cc.type()))
                    );
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN InvokeSpecial
//~ super.toString\(\) == "InvokeSpecial.*?"
//TEST:END

[id=new]
=== `new` expression

The `new` expression invokes a constructor and returns the resultant newly-created object instance.
It is equivalent to `new ClassName(...)` in Java.
The return type of a `new` expression is equal to the "owner" type of the <<methoddesc,constructor descriptor>>.

As a convenience, overloads of `new_(...)` exist which accept the type to build followed by the arguments; the descriptor will automatically be constructed based on the static types of the arguments and the type to build.

//TEST:BEGIN
.Example of `new`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;

public class NewExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("New", cc -> {
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // this variation builds a descriptor on the fly for us
                    LocalVar ex = b0.localVar("ex", b0.new_(RuntimeException.class, Const.of("This is an exception I just made")));
                    b0.throw_(ex);
                });
            });
        });
    }
}
----
//TEST:END

[id=new-array]
=== `newArray` and `newEmptyArray`

The `newArray` expression constructs an array whose contents are then initialized to the values which are provided.
The `newEmptyArray` expression constructs an array of a given length.
Both methods accept the array component type to determine the type of array to construct.

//TEST:BEGIN
.Example of `newArray` and `newEmptyArray`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;

public class NewArrayExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NewArray", cc -> {
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar emptyArray = b0.localVar("emptyArray", b0.newEmptyArray(String.class, 5));
                    LocalVar fullArray = b0.localVar("fullArray", b0.newArray(String.class,
                        Const.of("one"),
                        Const.of("two"),
                        Const.of("three"),
                        Const.of("four"),
                        Const.of("five")
                    ));
                    b0.printf("Empty array is: %s%n", b0.arrayToString(emptyArray));
                    b0.printf("Full array is: %s%n", b0.arrayToString(fullArray));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN NewArray
//= Empty array is: [null, null, null, null, null]
//= Full array is: [one, two, three, four, five]
//TEST:END

For convenience, an array may be constructed from a list of arbitrary items and a mapping function that turns the items into ``Expr``s.

//TEST:BEGIN
.Example of `newArray` with mapping
[source,java]
----
import java.nio.file.Path;

import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;

public class NewArrayWithMappingExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NewArrayWithMapping", cc -> {
            cc.staticMethod("main", mc -> {
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar array = b0.localVar("array", b0.newArray(String.class,
                        List.of("one", "two", "three", "four", "five"), Const::of));
                    b0.printf("Array is: %s%n", b0.arrayToString(array));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN NewArrayWithMapping
//= Array is: [one, two, three, four, five]
//TEST:END

[id=anonymous]
=== Anonymous class expressions

Like in Java, it is possible to define an expression which is an instance of an anonymous class.
Anonymous class expressions may be defined to capture values from the enclosing scope, as well as to pass parameter arguments to the constructor of the base class of the anonymous class.
Note that the base class of interface-based anonymous classes is always `java.lang.Object`, whose sole constructor does not accept any arguments.

//TEST:BEGIN
.Example of an anonymous class expression
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.Var;

public class AnonymousClassExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("AnonymousClass", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar str = b0.localVar("str", "The captured string");
                    b0.printf("The string is: %s%n", b0.newAnonymousClass(Object.class, acc -> {
                        // capture the `str` variable from the enclosing scope
                        Var myStr = acc.capture(str);
                        acc.method("toString", amc -> {
                            amc.returning(String.class);
                            amc.body(b1 -> {
                                // return the captured string
                                b1.return_(myStr);
                            });
                        });
                    }));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN AnonymousClass
//= The string is: The captured string
//TEST:END

[id=lambdas]
=== Lambda expressions

//TEST:BEGIN
.Example of a lambda expression
[source,java]
----
import java.nio.file.Path;
import java.util.function.Consumer;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Expr;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class LambdaExample {
    private static final MethodDesc consumerAccept = MethodDesc.of(
        Consumer.class,
        "accept",
        void.class,
        Object.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Lambda", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    Expr printer = b0.lambda(Consumer.class, lc -> {
                        ParamVar toPrint = lc.parameter("toPrint", 0);
                        lc.body(b1 -> {
                            b1.printf("%s%n", toPrint);
                            b1.return_();
                        });
                    });
                    b0.invokeInterface(consumerAccept, printer, Const.of("Print me!"));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Lambda
//= Print me!
//TEST:END

[id=control]
== Control flow

Gizmo provides many control flow constructs comprising a superset of what is available in the Java language.

[id=block]
=== `block`

The `block(...)` operation constructs a new block with its own scope.
See <<blocks>> for information about creating and using blocks.

[id=break]
=== `break_`

The `break_(...)` operation exits the block identified by its `BlockCreator` argument.
Control will resume at the next instruction after the target block (even if the target block otherwise exits abnormally).
The target block must enclose the block that contains the instruction or an exception will be thrown.
The target block must not be the outermost block of a method or constructor.

//TEST:BEGIN
.Example of `break_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;

public class BreakExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Break", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // n.b. the b0 block cannot be a "break" target
                    b0.block(b1 -> {
                        b1.if_(b1.lt(args.length(), 1), b2 -> {
                            // we'll break out of b1 to return
                            b2.break_(b1);
                        });
                        b1.printf("The first argument is: %s%n", args.elem(0));
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Break
//TEST:RUN Break a
//= The first argument is: a
//TEST:END

[id=return]
=== `return_`

The `return_(...)` operation immediately returns from the current method or constructor.
If an argument is given, the <<types,type>> of the argument must match the return type of the method.
Methods that do not return <<void-expr,`void`>> _must_ provide an argument.
The `return_(...)` operation cannot be used within initializers.

//TEST:BEGIN
.Example of `return_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ReturnExample {
    private static final MethodDesc parseLong = MethodDesc.of(
        Long.class,
        "parseLong",
        long.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Return", cc -> {
            // compute a factorial
            MethodDesc factorial = cc.staticMethod("factorial", mc -> {
                mc.returning(long.class);
                ParamVar n = mc.parameter("n", long.class);
                mc.body(b0 -> {
                    b0.ifElse(b0.eq(n, 0), b1 -> {
                        b1.return_(1);
                    }, b1 -> {
                        // return n * factorial(n - 1)
                        b1.return_(b1.mul(n, b1.invokeStatic(mc.desc(), b1.sub(n, 1))));
                    });
                });
            });
            // a nice main method
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.ifNot(b0.eq(args.length(), 1), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected one argument");
                    });
                    LocalVar n = b0.localVar("n", b0.invokeStatic(parseLong, args.elem(0)));
                    LocalVar res = b0.localVar("res", b0.invokeStatic(factorial, n));
                    b0.printf("The factorial of %d is %d%n", n, res);
                    // void methods return nothing
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Return 5
//= The factorial of 5 is 120
//TEST:END

[id=throw]
=== `throw_`
The `throw_(...)` operation throws an exception which is given as its sole argument.
It is functionally equivalent to Java's `throw` operation.

There are convenience overloads which accept an exception type and optional string or `String`-typed expression which will construct the exception and throw it, all in one operation.

//TEST:BEGIN
.Example of `throw_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;

public class ThrowExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Throw", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.ne(args.length(), 7), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "I wanted exactly seven arguments");
                    });
                    b0.printf("Thank you!%n");
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Throw 1 2 3 4 5 6 7
//= Thank you!
//TEST:END

[id=goto]
=== `goto_`/`gotoStart`

The `goto_(...)` operation transfers control to the beginning of the target block which is given as the sole argument.
The target block must enclose the current block.
As a convenience, the `gotoStart()` is equivalent to calling `b.goto_(b)` where `b` is the current block.

To target cases of a `switch` from within that `switch`, use <<goto-case>> instead.

//TEST:BEGIN
.Example of `goto_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;

public class GotoExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Goto", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Hello world!%n");
                    b0.goto_(b0);
                    // no return is needed, because control never reaches here
                });
            });
        });
    }
}
----
//no TEST:RUN, because the generated program never ends
//TEST:END

[id=if]
=== `if_`/`ifElse`/`ifNot`/`cond`
The `if*(...)` and `cond(...)` operations work like the Java `if` and `?:` constructs, respectively.
The `if_(...)` operation accepts a condition and a block to execute if the condition is true.
The `ifNot(...)` operation accepts a condition and a block to execute if the condition is false.
The `ifElse(...)` and `cond(...)` operations accept a condition and a block for each of the true or false cases.
Additionally, the `cond(...)` operation returns an expression representing the output of the block that was executed based on the condition.

In all cases, the condition argument must have a type of `boolean`.

//TEST:BEGIN
.Example of `if_` and `cond`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;

public class IfExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("If", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // check arguments length
                    b0.ifNot(b0.eq(args.length(), 2), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected 2 arguments");
                    });
                    LocalVar len0 = b0.localVar("len0", b0.withString(args.elem(0)).length());
                    LocalVar len1 = b0.localVar("len1", b0.withString(args.elem(1)).length());
                    b0.if_(b0.eq(len0, len1), b1 -> {
                        b1.printf("Both arguments have the same length%n");
                    });
                    b0.ifElse(b0.lt(args.elem(0), args.elem(1)), b1 -> {
                        b1.printf("Argument 0 comes before argument 1%n");
                    }, b1 -> {
                        b1.printf("Argument 0 does not come before argument 1%n");
                    });
                    LocalVar str = b0.localVar("str", b0.cond(String.class, b0.eq(len0, 1), b1 -> {
                        b1.yield(Const.of("letter"));
                    }, b1 -> {
                        b1.yield(Const.of("letters"));
                    }));
                    b0.printf("Argument 0 has %d %s%n", len0, str);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN If a b
//= Both arguments have the same length
//= Argument 0 comes before argument 1
//= Argument 0 has 1 letter
//TEST:RUN If edc ba
//= Argument 0 does not come before argument 1
//= Argument 0 has 3 letters
//TEST:END

[id=logical]
=== `logicalAnd`/`logicalOr`

The `logicalAnd(...)` and `logicalOr(...)` constructs mirror the `&&` and `||` operators in Java.
These operators are control-flow-affecting because of their "short-circuiting" behavior: if evaluating the first argument is sufficient to resolve the expression, then the second argument is not evaluated.
For this reason, the second argument is given as a <<blocks,block>> which must <<yielding,yield>> a `boolean`-typed value.

//TEST:BEGIN
.Example of `logicalAnd` and `logicalOr`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class LogicalExample {
    private static final MethodDesc startsWith = MethodDesc.of(
        String.class,
        "startsWith",
        boolean.class,
        String.class
    );
    private static final MethodDesc endsWith = MethodDesc.of(
        String.class,
        "endsWith",
        boolean.class,
        String.class
    );

    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Logical", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.if_(b0.ne(args.length(), 1), b1 -> {
                        b1.throw_(IllegalArgumentException.class, "Expected one argument");
                    });
                    LocalVar arg = b0.localVar("arg", args.elem(0));
                    LocalVar startsWithFoo = b0.localVar("startsWithFoo", b0.invokeVirtual(startsWith, arg, Const.of("foo")));
                    b0.ifElse(b0.logicalAnd(startsWithFoo, b1 -> {
                        b1.yield(b1.invokeVirtual(endsWith, arg, Const.of("bar")));
                    }), b1 -> {
                        // true
                        b1.printf("It is a foo...bar!%n");
                    }, b1 -> {
                        // false
                        b1.if_(b1.logicalOr(startsWithFoo, b2 -> {
                            b2.yield(b2.invokeVirtual(endsWith, arg, Const.of("bar")));
                        }), b2 -> {
                            b2.printf("It is almost a foo...bar%n");
                        });
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Logical foo_bar
//= It is a foo...bar!
//TEST:RUN Logical foo_
//= It is almost a foo...bar
//TEST:RUN Logical _bar
//= It is almost a foo...bar
//TEST:RUN Logical quux
//TEST:END

[id=switch]
=== `switch_` and `switchEnum`
The `switch_(...)` and `switchEnum(...)` operations generally work equivalently to (non-enhanced) `switch` statement or expression in Java.
The type of the switch value is generally inferred from the static type of the argument; however, as a special case, switching on `enum` requires use of the `switchEnum(...)` method instead, because it is not possible to statically infer that a type is an `enum` type.

The types presently supported by `switch_(...)` are:

* `int` (or any type that promotes to `int`, including `boolean`)
* `long`
* `java.lang.String`
* `java.lang.Class` (exact matches only, not subtype matches)

The `switchEnum(...)` operation differs from Java in that it has the capability to match `enum` constants from any `enum` type in one switch.

Cases can be added using `case_(...)` on the `SwitchCreator`.
For convenience, a series of `caseOf(...)` methods exist which accept a constant value and a `BlockCreator`.
Cases do _not_ fall through.
To simulate fallthrough behavior, use <<goto-case,`gotoCase` or `gotoDefault`>>.

Either operation can be used as an expression by passing the expression output type as the first argument.
However, each case which exits must yield a value of the expected type.

//TEST:BEGIN
.Example of `switch_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;

public class SwitchExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Switch", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar arg = b0.localVar("arg", Const.of("help"));
                    b0.if_(b0.ge(args.length(), 1), b1 -> b1.set(arg, args.elem(0)));
                    b0.switch_(arg, s1 -> {
                        s1.caseOf("help", b2 -> b2.printf("Your job is to guess my favorite color!%n"));
                        s1.caseOf("brown", b2 -> b2.printf("No, it's not brown!%n"));
                        s1.caseOf("grey", b2 -> b2.printf("I'd spell that as \"gray\", but no.%n"));
                        s1.caseOf("red", b2 -> b2.printf("You guessed it!%n"));
                        s1.default_(b2 -> b2.printf("Incorrect! Sorry...%n"));
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Switch
//= Your job is to guess my favorite color!
//TEST:RUN Switch help
//= Your job is to guess my favorite color!
//TEST:RUN Switch brown
//= No, it's not brown!
//TEST:RUN Switch grey
//= I'd spell that as "gray", but no.
//TEST:RUN Switch green
//= Incorrect! Sorry...
//TEST:RUN Switch red
//= You guessed it!
//TEST:END

[id=goto-case]
==== `gotoCase`/`gotoDefault`
In order to jump to the start of a case of an enclosing switch, the `gotoCase(...)` or `gotoDefault(...)` operations may be used.
These methods accept the creator of the enclosing switch and, for `gotoCase(...)`, the constant value of the case to jump to.

[id=loop]
=== `loop`

The `loop(...)` operation works like <<block,`block(...)`>>, with the sole difference that the block will end with an implicit `gotoStart()` if the block is not terminated some other way.
The main benefit of using `loop(...)` over the combination of `block(...)` and `gotoStart()` is readability.

//TEST:BEGIN
.Example of `loop`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;

public class LoopExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Loop", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.loop(b1 -> {
                        b1.printf("Hello world!%n");
                    });
                    // control never reaches here
                });
            });
        });
    }
}
----
//no TEST:RUN, because the generated program never ends
//TEST:END

[id=while]
=== `while_`/`doWhile`

A loop with a conditional clause can be created using the `while_(...)` and `doWhile(...)` constructs.
Note that like in Java, `while_(...)` accepts the conditional _before_ the loop body, whereas `doWhile(...)`
accepts the conditional _after_ the loop body.

//TEST:BEGIN
.Example of `while`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;

public class WhileExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("While", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar count = b0.localVar("count", 0);
                    b0.while_(b1 -> b1.yield(b1.lt(count, 5)), b1 -> {
                        b1.printf("Count is %d!%n", count);
                        b1.inc(count);
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN While
//= Count is 0!
//= Count is 1!
//= Count is 2!
//= Count is 3!
//= Count is 4!
//TEST:END

//TEST:BEGIN
.Example of `doWhile`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;

public class DoWhileExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("DoWhile", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar count = b0.localVar("count", 0);
                    b0.doWhile(b1 -> {
                        b1.printf("Count is %d!%n", count);
                        b1.inc(count);
                    }, b1 -> b1.yield(b1.lt(count, 5)));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN DoWhile
//= Count is 0!
//= Count is 1!
//= Count is 2!
//= Count is 3!
//= Count is 4!
//TEST:END

[id=for-each]
=== `forEach`

The `forEach(...)` construct is similar to the corresponding Java language structure.
It can be used to iterate over collections or arrays.
A parameter is used to specify the name of a local variable which will contain the current item in the block.
The `LocalVar` instance is passed into the block builder as its second argument.

//TEST:BEGIN
.Example of `forEach`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;

public class ForEachExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("ForEach", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.forEach(args, (b1, arg) -> {
                        b1.printf("Argument is %s%n", arg);
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN ForEach foo bar baz
//= Argument is foo
//= Argument is bar
//= Argument is baz
//TEST:END

[id=continue]
=== `continue_`

A loop can be resumed early using `continue_(...)`.
This works much like the `continue` keyword in Java.

The difference between `continue_(...)` and `gotoStart(...)` is that `continue_(...)`
will always reinterpret the loop condition (if any),
whereas `gotoStart` will go to the top of the block regardless of the loop condition.

//TEST:BEGIN
.Example of `continue_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;

public class ContinueExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Continue", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar count = b0.localVar("count", 0);
                    b0.doWhile(b1 -> {
                        b1.printf("Count is %d!%n", count);
                        b1.if_(b1.ne(b1.rem(count, 3), 0), b2 -> {
                            b2.inc(count);
                            b2.continue_(b1);
                        });
                        b1.printf("...divisible by 3!%n");
                        b1.inc(count);
                    }, b1 -> b1.yield(b1.lt(count, 5)));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Continue
//= Count is 0!
//= ...divisible by 3!
//= Count is 1!
//= Count is 2!
//= Count is 3!
//= ...divisible by 3!
//= Count is 4!
//TEST:END

[id=try]
=== `try_`

The `try_(...)` operation encapsulates a block of code which may throw an exception
and allows for the equivalent of `catch` and `finally` clauses to be defined.

The `try_(...)` method itself accepts a `TryCreator`, which in turn has methods to define
`catch_(...)` cases and a `finally_(...)` case.
These work similarly to their Java language equivalents.

For `catch_(...)` clauses, you may specific either a single throwable type or a set of throwable types.
If a set of throwable types is given as `ClassDesc` values, then the `ClassDesc` of a common
supertype of all the given types must also be given.
Otherwise, the type is automatically detected.
A local variable containing the caught exception will be given to the catch block builder as its second argument.
The name of the variable is provided to the `catch_(...) method as an argument.

The `finally_(...)` clause, if given, is run at every possible exit path from the body of the `try_(...)`.

//TEST:BEGIN
.Example of `try_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class TryExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Try", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar word = b0.localVar("word", args.elem(0));
                    b0.try_(t1 -> {
                        t1.body(b2 -> {
                            b2.printf("The integer value is %d%n", b2.invokeStatic(
                                MethodDesc.of(Integer.class, "parseInt", int.class, String.class),
                                word)
                            );
                        });
                        t1.catch_(NumberFormatException.class, "e", (b2, e) -> {
                            b2.printf("Value is not a number!%n");
                        });
                        t1.finally_(b2 -> {
                            b2.printf("Thanks for playing!%n");
                        });
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Try 1234
//= The integer value is 1234
//= Thanks for playing!
//TEST:RUN Try foobar
//= Value is not a number!
//= Thanks for playing!
//TEST:END


[id=synchronized]
=== `synchronized_`

Use the `synchronized_(...)` method to run the given block with the monitor of the given object held.

//TEST:BEGIN
.Example of `synchronized_`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class SynchronizedExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Synchronized", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar obj = b0.localVar("obj", b0.new_(Object.class));
                    MethodDesc holdsLock = MethodDesc.of(Thread.class, "holdsLock", boolean.class, Object.class);
                    b0.printf("Lock held = %s%n", b0.invokeStatic(holdsLock, obj));
                    b0.synchronized_(obj, b1 -> {
                        b1.printf("Lock held = %s%n", b1.invokeStatic(holdsLock, obj));
                    });
                    b0.printf("Lock held = %s%n", b0.invokeStatic(holdsLock, obj));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Synchronized
//= Lock held = false
//= Lock held = true
//= Lock held = false
//TEST:END

[id=auto-close]
=== `autoClose`

The `autoClose(...)` operation accepts a block that is executed using a given closeable resource.
When the block exits, the resource is safely closed, even if the exit is exceptional.

There are two forms of `autoClose(...)`.
One accepts a `Var` which contains the resource to be closed after the block.
The other accepts an arbitrary `Expr` which is stored into a `LocalVar` with the given name
which in turn is passed in to the block builder as its second argument.

//TEST:BEGIN
.Example of `autoClose`
[source,java]
----
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class AutoCloseExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("AutoClose", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    MethodDesc MD_newDirectoryStream = MethodDesc.of(
                        Files.class,
                        "newDirectoryStream",
                        DirectoryStream.class,
                        Path.class);
                    MethodDesc MD_Path_of = MethodDesc.of(
                        Path.class,
                        "of",
                        Path.class,
                        String.class,
                        String[].class
                    );
                    LocalVar ds = b0.localVar("ds",
                        b0.invokeStatic(MD_newDirectoryStream,
                            b0.invokeStatic(MD_Path_of, Const.of("."),
                                b0.newEmptyArray(String.class, 0)
                        )));
                    LocalVar found = b0.localVar("found", false);
                    b0.autoClose(ds, b1 -> {
                        b1.forEach(ds, (b2, path) -> {
                            b2.if_(b2.exprEquals(b2.exprToString(path), Const.of("./MANUAL.adoc")), b3 -> {
                                b3.set(found, true);
                                b3.break_(b1);
                            });
                        });
                    });
                    b0.printf("Found = %s%n", found);
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN AutoClose
//= Found = true
//TEST:END

[id=annotations]
== Adding annotations

Any element or type that can be annotated implements the `AnnotatableCreator` interface.
This interface defines several `addAnnotation(...)` methods which allow annotations to
be added to the element or type based on one of:

* An existing Java annotation instance (i.e. implementing `java.lang.annotation.Annotation`)
* The `Class` object of an annotation type
* The descriptor of an annotation type

In the latter two cases, you may also define annotation property values using a builder
which accepts an instance of `AnnotationCreator`.
With this creator, the builder may define annotation properties in a type-safe manner
using the `add(...)` and `addArray(...)` methods.

When adding annotations of annotation type, the `add(...)` method accepts a nested
`AnnotationCreator` to define the properties of the inner annotation.

//TEST:BEGIN
.Example of annotating elements
[source,java]
----
import java.lang.annotation.Annotation;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class AnnotationExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Annotation", cc -> {
            cc.addAnnotation(Deprecated.class, a0 -> {
                a0.add(Deprecated::since, "The beginning");
                a0.add(Deprecated::forRemoval, false);
            });
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar ann = b0.localVar("ann", b0.invokeVirtual(
                        MethodDesc.of(Class.class, "getAnnotation", Annotation.class, Class.class),
                        Const.of(cc.type()),
                        Const.of(Deprecated.class)
                    ));
                    b0.printf("Found %s%n", b0.invokeInterface(
                        MethodDesc.of(Annotation.class, "annotationType", Class.class),
                        ann
                    ));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Annotation
//= Found interface java.lang.Deprecated
//TEST:END

[id=helpers]
== Helper methods

There are many helper methods on `BlockCreator` which are designed to simplify
the most repetitive method calls and constructs.

[id=assertions]
=== Assertions

Assertions in Gizmo are more or less equivalent to Java's `assert` keyword.
One difference is that class assertion status for Gizmo classes is computed lazily
rather than at class initialization time.

//TEST:BEGIN
.Example of assertions
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class AssertionExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Assertion", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.assert_(b1 -> {
                        b1.yield(b1.exprEquals(
                            Const.of("Assertion"),
                            b1.invokeVirtual(MD_Class.getName, Const.of(cc.type()))
                        ));
                    }, "Class name was unexpected");
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Assertion
//TEST:END

[id=expr-equals]
=== `exprEquals`/`exprHashCode`/`exprToString`

The basic methods on `Object` for equality, hashing, and stringifying are among the most frequently
used methods in the Java language.
They may be easily invoked on any value using helper methods found directly on the block creator.
If the value is not an `Object` of some sort,
the corresponding static method on its box type will automatically be used instead.

//TEST:BEGIN
.Example of `exprEquals`, `exprHashCode`, and `exprToString`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class BasicMethodsExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("BasicMethods", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar arg = b0.localVar("arg", args.elem(0));
                    b0.printf("Hash of %s is %s%n", arg, b0.exprToString(b0.exprHashCode(arg)));
                    b0.if_(b0.exprEquals(Const.of("ARcZguv"), arg), b1 -> {
                        b1.printf("You found the secret string!%n");
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN BasicMethods YYHCCTL
//= Hash of YYHCCTL is 0
//TEST:RUN BasicMethods HelloWorld
//= Hash of HelloWorld is 439329280
//TEST:RUN BasicMethods ARcZguv
//= Hash of ARcZguv is 0
//= You found the secret string!
//TEST:END

[id=array-equals]
=== `arrayEquals`/`arrayHashCode`/`arrayToString`

The `arrayEquals`, `arrayHashCode`, and `arrayToString` methods wrap
the corresponding methods on `java.util.Arrays` for convenience.

//TEST:BEGIN
.Example of `arrayEquals`, `arrayHashCode`, and `arrayToString`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ArrayBasicMethodsExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("ArrayBasicMethods", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Arguments are %s%n", b0.arrayToString(args));
                    b0.printf("Hash of arguments is %s%n", b0.arrayHashCode(args));
                    b0.printf("Equal to \"foo bar baz\": %s%n", b0.arrayEquals(
                        args,
                        b0.newArray(String.class, Const.of("foo"), Const.of("bar"), Const.of("baz"))
                    ));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN ArrayBasicMethods Hello world goodbye
//= Arguments are [Hello, world, goodbye]
//= Hash of arguments is 1895331920
//= Equal to "foo bar baz": false
//TEST:RUN ArrayBasicMethods foo bar baz
//= Arguments are [foo, bar, baz]
//= Hash of arguments is 100755981
//= Equal to "foo bar baz": true
//TEST:END

[id=class-for-name]
=== `classForName`

The `Class.forName(...)` method can be called directly by using `classForName(...)` on the block creator.

//TEST:BEGIN
.Example of `classForName`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Expr;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ClassForNameExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("ClassForName", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Loaded %s%n", b0.classForName(args.elem(0)));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN ClassForName ClassForName
//= Loaded class ClassForName
//TEST:RUN ClassForName java.io.Serializable
//= Loaded interface java.io.Serializable
//TEST:END

[id=close]
=== `close`

The `close(...)` method on `BlockCreator` simply closes its argument.

See also <<auto-close>>.

//TEST:BEGIN
.Example of `close`
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class CloseExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Close", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // close System.out
                    b0.close(b0.getStaticField(FD_System.out));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Close
//TEST:END

[id=iterate]
=== `iterate`

The `iterate` method of the `java.lang.Iterable` interface can be invoked directly on an object
by calling `iterate(...)` on the block creator.

//TEST:BEGIN
.Example of `iterate`
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class IterateExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Iterate", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar argsList = b0.localVar("argsList", b0.invokeStatic(MD_List.of_array, args));
                    LocalVar itr = b0.localVar("itr", b0.iterate(argsList));
                    b0.printf("Has at least one: %s%n", b0.invokeInterface(MD_Iterator.hasNext, itr));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Iterate
//= Has at least one: false
//TEST:RUN Iterate foo bar baz
//= Has at least one: true
//TEST:END

[id=current-thread]
=== `currentThread`

The current thread expression can be acquired using `currentThread(...)`.

//TEST:BEGIN
.Example of `currentThread`
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class CurrentThreadExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("CurrentThread", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Current thread is %s%n", b0.currentThread());
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN CurrentThread
//~ Current thread is .*?main.*
//TEST:END

[id=optional]
=== `optionalOf`/`optionalOfNullable`/`optionalEmpty`

To easily wrap an object expression with `Optional`, use `optionalOf(...)` and `optionalOfNullable(...)`.
They are equivalent to calling `Optional.of(...)` and `Optional.ofNullable(...)`, respectively.

The `optionalEmpty(...)` is equivalent to calling `Optional.empty()`.

//TEST:BEGIN
.Example of `optionalOf`/`optionalOfNullable`/`optionalEmpty`
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class OptionalExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Optional", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Example 1: %s%n", b0.optionalOf(Const.of("Hello")));
                    b0.printf("Example 2: %s%n", b0.optionalOfNullable(Const.of("Hello again")));
                    b0.printf("Example 3: %s%n", b0.optionalOfNullable(Const.ofNull(String.class)));
                    b0.printf("Example 4: %s%n", b0.optionalEmpty());
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Optional
//= Example 1: Optional[Hello]
//= Example 2: Optional[Hello again]
//= Example 3: Optional.empty
//= Example 4: Optional.empty
//TEST:END

[id=collection-of]
=== `mapOf`/`setOf`/`listOf`/`mapEntry`

Collections can be constructed in a similar way to <<new-array,arrays>> using the following helper methods:

* `mapOf(...)` as a shortcut for calling `Map.of(...)`
* `setOf(...)` as a shortcut for calling `Set.of(...)`
* `listOf(...)` as a shortcut for calling `List.of(...)`
* `mapEntry(...)` as a shortcut for calling `Map.entry(...)`

Note that it is also possible to create these values <<const,as constants>> if desired.

//TEST:BEGIN
.Example of `mapOf`/`setOf`/`listOf`/`mapEntry`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class CollectionExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Collection", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("List example: %s%n", b0.listOf(
                        Const.of("foo"),
                        Const.of("bar"),
                        Const.of("baz")
                    ));
                    b0.printf("Set example: %s%n", b0.setOf(
                        Const.of("hello"),
                        Const.of("goodbye")
                    ));
                    b0.printf("Map example: %s%n", b0.mapOf(
                        Const.of("foo"), Const.of("hello"),
                        Const.of("bar"), Const.of("goodbye")
                    ));
                    b0.printf("Map entry example: %s%n", b0.mapEntry(
                        Const.of("foo"), Const.of("hello")
                    ));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Collection
//= List example: [foo, bar, baz]
//~ Set example: \[(?:hello, goodbye|goodbye, hello)\]
//~ Map example: \{(?:foo=hello, bar=goodbye|bar=goodbye, foo=hello)\}
//= Map entry example: foo=hello
//TEST:END

[id=boxing]
=== `box`/`unbox`

While Gizmo is able to auto-box/auto-unbox values in most situations,
sometimes it is necessary, useful, or desirable to explicitly box or unbox values.
The `box` and `unbox` methods explicitly box primitive values
or unbox primitive wrapper objects.

//TEST:BEGIN
.Example of `box`/`unbox`
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class BoxExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Box", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Explicitly boxed: %d%n", b0.box(Const.of(123)));
                    b0.printf("Box, unbox, rebox: %d%n", b0.box(b0.unbox(b0.box(Const.of(456)))));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Box
//= Explicitly boxed: 123
//= Box, unbox, rebox: 456
//TEST:END

[id=locked]
=== `locked`

The `locked(...)` method works exactly like the <<synchronized>> method,
except that it operates on `java.util.concurrent.locks.Lock` instead of an object monitor.

//TEST:BEGIN
.Example of `locked`
[source,java]
----
import java.nio.file.Path;
import java.util.concurrent.locks.ReentrantLock;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class LockedExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Locked", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar lock = b0.localVar("lock", b0.new_(ReentrantLock.class));
                    b0.locked(lock, b1 -> {
                        b1.printf("This is inside the lock");
                    });
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Locked
//= This is inside the lock
//TEST:END


[id=fences]
=== Fences

When writing advanced concurrent code, it is sometimes necessary to emit an explicit fence.
The following fence types are supported:

* `loadLoadFence()` - equivalent to `VarHandle.loadLoadFence()`
* `storeStoreFence()` - equivalent to `VarHandle.storeStoreFence()`
* `acquireFence()` - equivalent to `VarHandle.acquireFence()`
* `releaseFence()` - equivalent to `VarHandle.releaseFence()`
* `fullFence()` - equivalent to `VarHandle.fullFence()`
* `reachabilityFence(...)` - equivalent to `Reference.reachabilityFence(...)`

[id=wrappers]
== Object wrappers

Gizmo provides operation wrappers around expressions of common object types to allow for a more
fluent and readable invocation style.
The methods to instantiate the wrappers start with `with` and accept the receiver expression.

Object wrappers are not normally able to be reused since they directly wrap their expressions,
and are bound to the block which created them.

//TEST:BEGIN
.Example of object wrappers
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.LocalVar;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.desc.MethodDesc;

public class OpsExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("Ops", cc -> {
            cc.staticMethod("main", mc -> {
                ParamVar args = mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    LocalVar arg = b0.localVar("arg", args.elem(0));
                    // b0.invokeVirtual(MD_String.length, arg);
                    b0.printf("Argument length is %d%n", b0.withString(arg).length());
                    // b0.invokeVirtual(MD_Object.getClass, arg);
                    b0.printf("Argument type is %s%n", b0.withObject(arg).getClass_());
                    // b0.invokeVirtual(MD_String.concat, arg, Const.of(...));
                    b0.printf("Improved argument is %s%n", b0.withString(arg).concat(Const.of("... but better")));
                    b0.return_();
                });
            });
        });
    }
}
----
//TEST:RUN Ops foobar
//= Argument length is 6
//= Argument type is class java.lang.String
//= Improved argument is foobar... but better
//TEST:END

[id=generics]
== Generic types and type annotations

A generated element may need to have (possibly annotated) generic type information.
This may be due to a generated class needing to interact with `javac`,
or because of a framework that will consume the class.

Gizmo provides mechanisms to insert generic types in places where the JVM
supports generic type information and/or type annotations in a way that
naturally integrates with the Gizmo type system.
Methods which accept a type in the form of `ClassDesc` and/or `Class<?>`,
but which also support generic or annotated types,
generally have an overloaded variant which accepts a `GenericType` instead.

[id=generic-types]
=== Generic type representation

Generic types are represented by the `GenericType` class.
A `GenericType` instance may be annotated with type annotations, and
(depending on its type) may contain type arguments.
If a generic type reflects a class and does not contain type annotations
or type arguments, then it will generally be omitted from the target class
file for efficiency reasons.

The `GenericType` class has several subclasses to represent the different kinds
of generic type:

* `GenericType` - the base type
** `GenericType.OfPrimitive` - representing primitive types
** `GenericType.OfReference` - the base type of generic referenceable types
*** `GenericType.OfArray` - representing all generic array types
*** `GenericType.OfThrows` - the base type of all generic types that can appear in a `throws` declaration
**** `GenericType.OfClass` - the base type of all class generic types, which may have type arguments
***** `GenericType.OfInnerClass` - representing inner class types
***** `GenericType.OfRootClass` - representing top-level and static nested class types
**** `GenericType.OfTypeVariable` - representing type variables

All `GenericType` subclasses are annotatable.

[id=type-arguments]
=== Type argument representation

Type arguments are represented by instances of `TypeArgument`, which may
represent exact or wildcard types.
There are subclasses to represent each kind of `TypeArgument`:

* `TypeArgument` - the base type
** `TypeArgument.OfExact` - a type argument of one exact type, which must be a `GenericType.OfReference`
** `TypeArgument.OfWildcard` - the base type of all wildcard type argument types; wildcard types may be annotated
*** `TypeArgument.OfExtends` - a type argument with an upper bound, which must be a `GenericType.OfReference`; for example: `? extends CharSequence`
*** `TypeArguments.OfSuper` - a type argument with a lower bound, which must be a `GenericType.OfReference`; for example: `? super String`
*** `TypeArguments.OfUnbounded` - the unbounded type argument (`?`)

Additionally, there is an interface `TypeArgument.OfTyped` which is implemented by the two bounded wildcard types and by `OfExact`, indicating that the type argument has a real-typed bound.

NOTE: While the Java language makes no distinction between a wildcard with no bound (`?`) and a wildcard with an `Object`-typed upper bound (`? extends Object`), the JVM specification does make such a distinction. Furthermore, the Java compiler `javac` will emit different attribute content in either case.

[id=constructing-generic-types]
=== Constructing generic types

Instances of `GenericType`, are built
using factory methods found on that class,
or by creating derived instances using instance methods
which yield new instances.
Instances of `GenericType` are themselves immutable.

Like `GenericType`, instances of `TypeArgument` are instantiated using
factory methods or by acquiring derived instances from existing instances.

//TEST:BEGIN
.Example of constructing a complex generic type
[source,java]
----
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.List;
import java.util.Map;

import io.quarkus.gizmo2.GenericType;
import io.quarkus.gizmo2.TypeArgument;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE_USE)
@interface Silly {
    int silliness() default 1;
}

@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE_USE)
@interface Serious {
    int seriousness() default 1;
}

public class GenericTypeExample {
    public static void main(String[] args) {
        // simple type: @Serious int
        GenericType.OfPrimitive seriousInt = GenericType.ofPrimitive(int.class).withAnnotation(Serious.class);
        // array type: @Serious int @Silly []
        GenericType.OfArray sillyArraySeriousInt = seriousInt.arrayType().withAnnotation(Silly.class);
        // simple type: @Silly String
        GenericType.OfClass sillyString = GenericType.ofClass(String.class).withAnnotation(Silly.class);
        // type bound: @Serious(seriousness = 2) ? extends @Silly String
        TypeArgument.OfExtends extendsSillyString =
                TypeArgument.ofExtends(sillyString).withAnnotation(Serious.class, ac -> ac.add(Serious::seriousness, 2));
        // type: @Silly List<@Serious(seriousness = 2) ? extends @Silly String
        GenericType.OfClass sillyList =
                GenericType.ofClass(List.class).withAnnotation(Silly.class).withArguments(List.of(extendsSillyString));
        // construct the following complex type:
        // Map<@Silly List<@Serious(seriousness = 2) ? extends @Silly String>, @Serious int @Silly []>
        GenericType.OfClass mapType = GenericType.ofClass(Map.class)
            .withArguments(List.of(
                TypeArgument.ofExact(sillyList),
                TypeArgument.ofExact(sillyArraySeriousInt)
            ));
        System.out.printf("Our map type is: %s%n", mapType);
    }
}
----
//TEST:OUTPUT GenericTypeExample
//= Our map type is: java.util.Map<java.util.@Silly List<@Serious(seriousness=2) ? extends java.lang.@Silly String>, @Serious int @Silly []>
//TEST:END

[id=type-parameters]
=== Adding type parameters

Classes and methods may define type parameters, optionally with bounds,
and then use those type parameters as generic types.

//TEST:BEGIN
.Example of a class with type parameters
[source,java]
----
import static io.quarkus.gizmo2.desc.Descs.*;

import java.nio.file.Path;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.GenericType;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.TypeArgument;
import io.quarkus.gizmo2.desc.MethodDesc;

public class TypeParamExample {
    public static void main(String[] ignored) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.interface_("CharSequenceList", cc -> {
            GenericType.OfTypeVariable tee = cc.typeParameter("T", tpc -> tpc.setFirstBound(GenericType.ofClass(CharSequence.class)));
            cc.extends_(GenericType.ofClass(List.class).withArguments(List.of(
                TypeArgument.ofExact(tee)
            )));
        });
    }
}
----
//TEST:COMPILE
//TEST:END

[id=gizmo1]
== Migration from Gizmo 1

The differences between Gizmo 1 and Gizmo 2 do not end on the API level.
There are conceptual differences that make the transition less of a mechanical process and more of a creative endeavor.

This chapter lists those differences and illustrates them with some good and bad code patterns.

=== Values and variables

To represent values, Gizmo 1 has the venerable `ResultHandle` class, which is almost always a local variable (not absolutely always, which is why the API doesn't let you assign to it; you have to use `AssignableResultHandle` for that).
This means you don't really have to care about order in which you produce values or about using them multiple times -- everything just works.
There's obvious overhead though: for each use of the value, it needs to be loaded from the variable to the stack.

On the other hand, Gizmo 2 represents values as ``Expr``s, which are very often not local variables.
An `Expr` is a value that is, at the time of its creation, on top of the stack, nothing more.
This means the order of producing values suddenly matters and they may not be reused!
To create a local variable (`LocalVar`) out of an expression, you have to call `BlockCreator.localVar()`.

In Gizmo 2, only `Var`, `Const` and `This` expressions are reusable and order of their creation doesn't matter.
All other kinds of ``Expr``s _may not_ be reused and must be created in the correct order.

As a general rule, you should use plain ``Expr``s in a single Java expression, such as a method call on the `BlockCreator`.

*DO:*

[source,java]
----
BlockCreator bc = ...;

bc.printf("1 + 2 * 3 / 4 = %s", bc.exprToString(
        bc.add(Const.of(1), bc.div(bc.mul(Const.of(2), Const.of(3)), Const.of(4)))));
----

However, when you have to create a Java local variable, it should usually _not_ be an `Expr`, but a `LocalVar`.

*DO:*

[source,java]
----
BlockCreator bc = ...;

LocalVar interim = bc.localVar("interim",
        bc.add(Const.of(1), bc.div(bc.mul(Const.of(2), Const.of(3)), Const.of(4))));

bc.printf("1 + 2 * 3 / 4 = %s", bc.exprToString(interim));
----

*DON'T:*

[source,java]
----
BlockCreator bc = ...;

Expr interim = bc.add(Const.of(1), bc.div(bc.mul(Const.of(2), Const.of(3)), Const.of(4)));

bc.printf("1 + 2 * 3 / 4 = %s", bc.exprToString(interim));
----

Note that this last example would work just fine.
However, if you created _another_ `Expr` between `interim` and the call to `printf()`, the code would no longer work and you would get an exception.

*DON'T:*

[source,java]
----
BlockCreator bc = ...;

Expr interim = bc.add(Const.of(1), bc.div(bc.mul(Const.of(2), Const.of(3)), Const.of(4)));

Expr somethingElse = bc.add(Const.of(5), Const.of(6));

bc.printf("1 + 2 * 3 / 4 = %s", bc.exprToString(interim));
----

This is because, as mentioned above, values that are not reusable are simply stored on the stack.
Whatever is on the top of the stack must be used first.
If you do store ``Expr``s into variables, you're leaning into an advanced territory and Gizmo at least verifies that you follow the "stack-like" usage policy.

=== Callbacks should be pure functions

The Gizmo 2 API uses callbacks heavily: `Gizmo.class_()` accepts a callback, `ClassCreator.method()` accepts a callback, `MethodCreator.body()` accepts a callback, and so on.
You should remember that these callbacks _may be invoked multiple times_.
This may happen due to the ClassFile API decisions, but the most common case is when generating `try`/`finally`: the callback passed to `finally_()` will be called once for each exit point in the `try_()` body.
Therefore, all these callbacks should be pure functions, which means:

- they should only take immutable inputs from the outside
- they should not have side effects

*DO:*

[source,java]
----
BlockCreator b0 = ...;

b0.try_(tc -> {
    tc.body(b1 -> {
        ...
    });
    tc.finally_(b1 -> {
        ...
    });
});
----

*DON'T:*

[source,java]
----
AtomicInteger counter = new AtomicInteger();

BlockCreator b0 = ...;

b0.try_(tc -> {
    tc.body(b1 -> {
        ...
    });
    tc.finally_(b1 -> {
        ...
        counter.incrementAndGet();
    });
});

if (counter.get() > 1) {
    ...
}
----

Side effects are often not that obvious, but they must be avoided nevertheless!

=== Explicit type casts

Gizmo 2 does some type conversions automatically:

* boxing (e.g. from `int` to `Integer` or to `Number`)
* unboxing (e.g. from `Integer` to `int`)
* primitive widening (e.g. from `int` to `long`)
* reference narrowing, but only from `Object`
* combinations
** primitive widening followed by boxing (e.g. from `int` through `long` to `Long`)
** unboxing followed by primitive widening (e.g. from `Integer` through `int` to `long`)
** reference narrowing (only from `Object`) followed by unboxing (e.g. from `Object` through `Integer` to `int`)

All other type conversions you have to do explicitly.
This is in contrast to Gizmo 1, where references were always cast automatically.

*DO:*

[source,java]
----
BlockCreator b0 = ...;

// call a method that declares a return type of `Number`
LocalVar number = b0.localVar("number", b0.invokeVirtual(...));

// but we know it actually is an `Integer`
LocalVar integer = b0.localVar("integer", b0.cast(number, Integer.class));

// call a method that declares a parameter type of `Integer`
b0.invokeVirtual(..., integer);
----

*DON'T:*

[source,java]
----
BlockCreator b0 = ...;

// call a method that declares a return type of `Number`
LocalVar number = b0.localVar("number", b0.invokeVirtual(...));

// call a method that declares a parameter type of `Integer`
b0.invokeVirtual(..., number);
----

=== Explicit captures in lambdas

When generating lambda expressions, you _must not_ use variables that belong to enclosing scopes.
Instead, you _have to capture them explicitly_ and use the captured variables instead.

This sounds super opaque, so let's illustrate with classic Java code first.

[source,java]
----
AtomicInteger counter = new AtomicInteger();

List<String> list = List.of("foo", "bar", "baz", "quux");
list.forEach(element -> {
    ... process element ...
    counter.incrementAndGet();
});
----

In this example, the `counter` variable is _captured_ in the lambda expression passed to `list.forEach()`.
The capture is _implicit_: you don't have to do anything extra, the Java compiler figures it all out for you.
The same happened in Gizmo 1: if you were creating a lambda expression (an anonymous class, in fact), you could use ``ResultHandle``s from the outside and Gizmo 1 figured it all out.

In Gizmo 2, captures are explicit.
At the beginning of creating a lambda, before creating its body, before even declaring its parameters, you have to capture all variables used in the lambda.

Assuming:

[source,java]
----
MethodDesc MD_Iterable_forEach = MethodDesc.of(Iterable.class,
        "forEach", void.class, Consumer.class);
MethodDesc MD_AtomicInteger_incrementAndGet = MethodDesc.of(AtomicInteger.class,
        "incrementAndGet", int.class);

BlockCreator b0 = ...;

LocalVar counter = b0.localVar("counter", b0.new_(AtomicInteger.class)).

LocalVar list = b0.localVar("list",
        b0.listOf(Const.of("foo"), Const.of("bar"), Const.of("baz"), Const.of("quux")));
----

*DO:*

[source,java]
----
b0.invokeInterface(MD_forEach, list, b0.lambda(Consumer.class, lc -> {
    Var capturedCounter = lc.capture("counter", counter);
    ParamVar element = lc.parameter("element", 0);
    lc.body(b1 -> {
        ... process element ...
        // using `capturedCounter` correctly
        b1.invokeVirtual(MD_AtomicInteger_incrementAndGet, capturedCounter);
    });
}));
----

*DON'T:*

[source,java]
----
b0.invokeInterface(MD_forEach, list, b0.lambda(Consumer.class, lc -> {
    ParamVar element = lc.parameter("element", 0);
    lc.body(b1 -> {
        ... process element ...
        // using `counter` incorrectly
        b1.invokeVirtual(MD_AtomicInteger_incrementAndGet, counter);
    });
}));
----

=== Methods that return `void`

If you generate a method that returns `void`, you must either call `return_()` without any parameter, or pass `Const.ofVoid()` to `return_()`.
Attempting to return a value from a `void`-returning method leads to an exception.

This is in contrast to Gizmo 1, which automatically drops such value.

*DO:*

[source,java]
----
ClassCreator cc = ...;

ClassDesc returnType = ...;

cc.method("doSomething", mc -> {
    mc.returning(returnType);
    mc.body(bc -> {
        Expr value = ... do something ...;
        bc.return_(mc.isVoidReturn() ? Const.ofVoid() : value);
    });
});
----

*DON'T:*

[source,java]
----
ClassCreator cc = ...;

ClassDesc returnType = ...;

cc.method("doSomething", mc -> {
    mc.returning(returnType);
    mc.body(bc -> {
        Expr value = ... do something ...;
        bc.return_(value);
    });
});
----

=== Invoking inherited methods

The bytecode instruction `invokespecial` is used to generate a "special" invocation.
This is most often used to invoke an inherited method, similarly to:

[source,java]
----
@Override
public void doSomething() {
    super.doSomething();
    ... do something else ...
}
----

Both Gizmo 1 and Gizmo 2 have a method to generate the `invokespecial` instruction.
In Gizmo 1, that is `invokeSpecialMethod()`, while in Gizmo 2, it is `invokeSpecial()`.

However, in Gizmo 1, `invokeSpecialMethod()` always assumes that the method is inherited from a _class_ and you have to use `invokeSpecialInterfaceMethod()` if the method is inherited from an _interface_.

In Gizmo 2, the `invokeSpecial()` method makes no such assumption.
Instead, it inspects the descriptor of the method to invoke: if it is a `ClassMethodDesc`, the method is inherited from a class, and if it is an `InterfaceMethodDesc`, the method is inherited from an interface.

Pay extra attention to this whenever you're rewriting an `invokeSpecialMethod()` call from Gizmo 1!
