= Gizmo User's Manual
:preface-title: introduction
:docname: user-manual
:toc:

[id=introduction]
== Introduction

Gizmo 2 is a library whose purpose is to make it relatively easy to generate reasonably efficient class files.

The API is loosely modeled after the https://openjdk.org/jeps/484[JDK class file API], in that elements are modeled using lexical scoping.
In contrast however, many things which would otherwise be subtly confusing or difficult are simplified considerably.

Since this library is used to build programs in a way that approximates the Java language itself, it contains many method names that conflict with Java keywords.
In these cases, the method name has a `\_` character appended to the method name (for example, `class_`, `switch_`, or `goto_`).

This library is an evolution of the earlier Gizmo 1 library with further conceptual simplifications and capabilities.
While Gizmo 2 is not source- or binary-compatible with Gizmo 1, it resides in a non-conflicting package space, so the two can coexist during a transition period of migrating from 1 to 2.

[id=quick-start]
== Quick start

To get started quickly, include the `io.quarkus.gizmo:gizmo2` artifact in your project build. The following code blob shows how to generate a simple class:

."Hello world" example
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;

public class HelloWorld {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("HelloWorldGenerated", cc -> {
            zc.staticMethod("main", mc -> {
                mc.public_();
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    b0.printf("Hello world!%n");
                    b0.return_();
                });
            });
        });
    }
}
----

[id=gizmo-interface]
== The `Gizmo` interface

The `Gizmo` interface is the primary entry point into the API.
Instances are created using the `Gizmo.create(...)` method, which accepts a <<classoutput>> instance.

The `Gizmo` instance can be used to create classes and interfaces, and can also be used to create derived `Gizmo` instances which have different defaults for access modifiers or a different <<classoutput>>.

[id=classoutput]
=== `ClassOutput`

Implementations of the `ClassOutput` interface receive the bytes of the generated classes and resources.

Users may implement this interface directly or use a provided implementation.

The `ClassOutput.fileWriter(Path)` static factory method returns a `ClassWriter` which writes classes and resources under the given target path.

[id=descriptors]
== Descriptors

The class file format itself encodes types and members using "descriptors", which are strings which unambiguously identify them.
Gizmo 2 uses object abstractions of these strings for convenience and safety.
Some of these object types are provided by the JDK, and others are defined by Gizmo.

[id=classdesc]
=== The `ClassDesc` interface

Types (primitives, classes and interfaces and their variations, and arrays) are identified using the `ClassDesc` interface, which is provided by the JDK as part of the `java.lang.constant` package.
Instances can be created using the various factory methods of that class.

.Example of creating a class descriptor for `java.lang.String`
[source,java]
----
import java.lang.constant.ClassDesc;

public static class ClassDescExample {
    public static void main(String[] args) {
        System.out.printf("The descriptor of String is: %s%n", ClassDesc.of("java.lang.String"));
    }
}
----

A class descriptor can also be derived from a `Class<?>` object by calling its `describeConstable` method.
Note that https://openjdk.org/jeps/371[hidden classes] will return an empty `Optional` from this method.

Since hidden classes are uncommon, the `Reflection2Gizmo.classDescOf(...)` method takes a `Class` and returns a `ClassDesc` directly.
In case of a hidden class (if you can obtain its `Class` object), this method throws an exception.

[id=fielddesc]
=== The `FieldDesc` interface

Fields are identified by the combination of the "owner" type (represented as a <<classdesc,`ClassDesc`>>), the field name (a `String`), and the field's type (another `ClassDesc`).
This is true for both static and instance fields, which therefore share an overall namespace.
In Gizmo, these identifiers are represented using the `FieldDesc` interface, which contains several factory methods for easy usage.

.Examples of various field descriptors
[source,java]
----
import java.io.PrintStream;
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.desc.FieldDesc;

public class FieldDescExample {
    public static void main(String[] args) {
        FieldDesc sysOut = FieldDesc.of(System.class, "out"); // the type is detected via reflection
        FieldDesc sysErr = FieldDesc.of(
            ClassDesc.of("java.lang.System"),
            "err",
            PrintStream.class
        );
        FieldDesc sysIn = FieldDesc.of(
            ClassDesc.of("java.lang.System"),
            "in",
            ClassDesc.of("java.io.InputStream")
        );
    }
}

----

[id=methoddesc]
=== `MethodDesc` and `ConstructorDesc`

Within the JVM, methods and constructors are represented the same way (the latter bearing the special name `<init>` and always returning `void`, but otherwise having the same structure).
Methods and constructors are uniquely identified by the combination of the "owner" type (a <<classdesc,`ClassDesc`>>), the member name (a `String`), and the type (a <<methodtypedesc,`MethodTypeDesc`>>).

Gizmo 2 represents these identifiers using the `MethodDesc` and `ConstructorDesc` interfaces.
Furthermore, the JVM makes a distinction between methods which exist on interfaces (and their derived types) versus methods which exist on classes (and their derived types).
This distinction is represented using the `ClassMethodDesc` and `InterfaceMethodDesc` sub-interfaces.

A `MethodDesc` can be constructed using reflection-based factory methods on the base `MethodDesc` interface.
These methods will automatically determine whether a `ClassMethodDesc` or `InterfaceMethodDesc` should be returned, based on the owner `Class` instance that is provided to these methods.

If the owner's `Class` instance is not readily available (for example, if it is a generated class or one not visible to the generator's class loader), then the factory methods on `ClassMethodDesc` and `InterfaceMethodDesc` may be used to return an instance of that type.

Since a `ConstructorDesc` always returns `void`, any attempt to create a `ConstructorDesc` with a non-`void` return type will result in an exception.

There are a wide variety of factory methods available for these types.
A few of the common ones are illustrated below.

.Examples of various method and constructor descriptors
[source,java]
----
import java.lang.constant.ClassDesc;

import io.quarkus.gizmo2.desc.ConstructorDesc;
import io.quarkus.gizmo2.desc.MethodDesc;
import io.quarkus.gizmo2.desc.ClassMethodDesc;
import io.quarkus.gizmo2.desc.InterfaceMethodDesc;

public class MethodDescExample {
    public static void main(String[] args) {
        ConstructorDesc stringCtor = ConstructorDesc.of(String.class, char[].class);

        MethodDesc hashCodeDesc = MethodDesc.of(Object.class, "hashCode", int.class);
        MethodDesc runDesc = InterfaceMethodDesc.of(
            ClassDesc.of("java.lang.Runnable"),
            "run",
            void.class
        );
        MethodDesc toStringDesc = ClassMethodDesc.of(
            ClassDesc.of("java.lang.Object"),
            "toString",
            String.class
        );
    }
}
----

[id=methodtypedesc]
=== The `MethodTypeDesc` interface

The type of a method or constructor is determined by its return and parameter types.
The JDK represents this type using the `MethodTypeDesc` interface in the `java.lang.constant` package.
This interface contains a factory method to compose instances from constituent <<classdesc,ClassDesc>> instances.

.Example of creating a `MethodTypeDesc`
[source,java]
----
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;

public class MethodTypeDescExample {
    public static void main(String[] args) {
        ClassDesc stringArray = ClassDesc.of("java.lang.String").arrayType();
        MethodTypeDesc mainType = MethodTypeDesc.of(
            ClassDesc.ofDescriptor("V"), // void
            stringArray
        );
    }
}
----

[id=creating-types]
== Creating types

Types may be created directly using methods on the <<gizmo-interface,`Gizmo`>> interface.
The general form of these methods accepts a consumer of a `ClassCreator` or `InterfaceCreator` instance, which is then used to construct the type and its constituent members.
Normally, an in-line lambda expression is used for this argument, which creates a lexical structure which is similar to that of a type definition in Java.
By convention, the parameter name `cc` is typically used for the `ClassCreator` or `InterfaceCreator` instance.

The creator instance passed to the consumer may add or remove flags, set the access level, modify the class version, extend interfaces or a base class, and add members to the type.

.Example of creating a simple class
[source,java]
----
import java.io.Serializable;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.ClassVersion;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class SimpleClassExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new class using the given lambda
        gizmo.class_("com.mycompany.SomeClass", cc -> {
            // we can implement interfaces
            cc.implements_(Serializable.class);
            // we can extend base classes
            cc.extends_(RuntimeException.class);
            // we can set flags
            cc.final_();
            // or...
            cc.addFlags(ModifierFlag.FINAL);
            // we can remove flags
            cc.removeFlag(ModifierFlag.SYNTHETIC);
            // we can set the access level
            cc.setAccess(AccessLevel.PACKAGE_PRIVATE);
            // or...
            cc.packagePrivate();
            // we can set the class version
            cc.setVersion(ClassVersion.V17);
        });
        // at this point, the class has been written to the output
    }
}
----

.Example of creating a simple interface
[source,java]
----
import java.io.Serializable;
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.ClassVersion;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class SimpleInterfaceExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new interface using the given lambda
        gizmo.interface_("com.mycompany.SomeInterface", cc -> {
            // we can extend other interfaces
            cc.extends_(Serializable.class);
            cc.extends_(Cloneable.class);
            // we can set flags
            cc.addFlags(ModifierFlag.SYNTHETIC);
            // we can remove flags
            cc.removeFlag(ModifierFlag.SYNTHETIC);
            // we can set the access level
            cc.public_();
            // or...
            cc.setAccess(AccessLevel.PUBLIC);
            // we can set the class version
            cc.setVersion(ClassVersion.V17);
        });
    }
}
----

[id=creating-fields]
== Creating fields

Fields may be added to types using the `field`, `staticField`, and `constantField` methods.
These methods accept a consumer for a `StaticFieldCreator` or `InstanceFieldCreator` instance.
The `field` method returns a <<fielddesc,`FieldDesc`>> for the newly created field.
The `staticField` and `constantField` methods return a <<fields,`StaticFieldVar`>> which may be used directly in expressions.

Fields may be initialized directly with a constant value at the time the field is defined by using the `setInitial` method.
For more complex initializers, the `setInitializer` method may be used, which accepts a <<blocks,code block creator>> which must yield a value for the field.
Initializers are automatically emitted into constructors or static initializers in the order that they are established.

By convention, the parameter name `fc` is typically used for the `FieldCreator` instance.

.Example of creating a class with some fields
[source,java]
----
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.desc.MethodDesc;

public class ClassWithFieldsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // create a new class using the given lambda
        gizmo.class_("com.mycompany.ClassWithFields", cc -> {
            // implicitly `int` because of the constant initializer
            cc.field("count", Const.of(123));
            // a more complex field
            cc.field("name", fc -> {
                fc.public_();
                fc.final_();
                fc.addFlag(ModifierFlag.TRANSIENT);
                // implicitly a `String` because of the initializer
                fc.setInitial("A more complex field");
            });
            // a field with a specified type and no initializer
            cc.field("problem", fc -> {
                fc.private_();
                fc.setType(Throwable.class);
            });
            // a public static final constant field
            cc.constantField("KIBI", Const.of(1024));
            // a regular static field
            cc.staticField("closed", fc -> {
                fc.volatile_();
                fc.setType(boolean.class);
            });
            // static fields may be final as well
            var nameArray = cc.staticField("nameArray", fc -> {
                fc.setType(String[].class);
                fc.final_();
                // initialize here or separately
            });
            // a more complex initializer example
            cc.field("namesAsList", fc -> {
                fc.setType(List.class);
                // blocks and expressions are covered elsewhere
                fc.setInitializer(b0 -> {
                    b0.yield(
                        b0.invokeStatic(
                            MethodDesc.of(Arrays.class, "asList", List.class, Object[].class),
                            b0.get(nameArray)
                        )
                    );
                });
            });
        });
    }
}
----

[id=creating-methods]
== Creating methods and constructors

Methods and constructors are created using one of several methods on the type creator instance.
The method used depends on the properties of the constructor or method being built, and the kind of type that the method or constructor belongs to.
They are as follows:

* `staticMethod(...)` creates a static method on a class or interface
* `ClassCreator.method(...)` creates a concrete instance method on a class
* `ClassCreator.abstractMethod(...)` creates an abstract instance method on a class
* `ClassCreator.staticNativeMethod(...)` creates a static native method on a class
* `ClassCreator.nativeMethod(...)` creates an instance native method on a class
* `ClassCreator.constructor(...)` creates a constructor on a class
* `ClassCreator.defaultConstructor()` causes the default no-argument constructor to be generated
* `InterfaceCreator.method(...)` creates an abstract instance method on an interface
* `InterfaceCreator.defaultMethod(...)` creates a default instance method on an interface
* `InterfaceCreator.privateMethod(...)` creates a private instance method on an interface

In some cases, there may be an implicit modifier or access level that cannot be changed on that particular member.
For example, interface private methods are always `private`, and abstract methods are always `abstract`.
It is not possible to change these modifier flags or access levels.
See <<modifiers>> for more information.

The method and constructor factory methods generally follow three different forms:

* A form which accepts <<methoddesc,a descriptor>> plus a creator consumer
* A form which accepts a name plus a creator consumer
* A form which accepts a name and a <<methodtypedesc,type descriptor>> plus a creator consumer

Note that the constructor factory methods do not accept a name argument.

If the type is given (either by giving the constructor/method descriptor or by giving the type descriptor), then the constructor's or method's <<parameters,parameter definitions>> (if any) must conform to the type given; otherwise, an error will be produced when the constructor or method is defined.

If the type is not given, it will be computed based on the types of the parameter definitions (if any) plus the return type (which defaults to `void`, and which cannot be changed for constructors).

The following is an example of defining constructors and methods.
Note that constructors and some types of methods have bodies containing program code, which is covered in more detail in the <<blocks>> section, and other features such as <<annotations,annotations>> and <<modifiers,access levels and modifiers>> which are explained in their respective sections.

.Example of defining constructors and methods
[source,java]
----
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.ParamVar;
import io.quarkus.gizmo2.This;
import io.quarkus.gizmo2.creator.BlockCreator;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.desc.FieldDesc;
import io.quarkus.gizmo2.desc.MethodDesc;

public class TypesWithMethodsAndConstructorsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // an interface to implement
        ClassDesc nh = gizmo.interface_("org.numberifier.NumberHolder", cc -> {
            cc.method("incrementNumber", mc -> {
                mc.public_();
                mc.returning(int.class);
                // no body on interface method
            });
            cc.defaultMethod("setNumber", mc -> {
                ParamVar newNumber = mc.parameter("newNumber", int.class);
                // returns void by default; just return without doing anything
                mc.body(BlockCreator::return_);
            });
            cc.staticMethod("newInstance", mc -> {
                // return an instance of this interface
                mc.returning(cc.type());
                mc.public_();
                mc.body(b0 -> {
                    b0.return_(
                        b0.new_(ClassDesc.of("org.numberifier.NumberHolderImpl"))
);
                });
            });
        });

        // a base class to extend
        ClassDesc anh = gizmo.class_("org.numberifier.AbstractNumberHolder", cc -> {
            cc.implements_(nh);
            cc.abstract_();
            cc.abstractMethod("incrementNumber", mc -> {
                mc.addAnnotation(Override.class);
                mc.public_();
                mc.returning(void.class);
            });
        });

        // the leaf class
        gizmo.class_("org.numberifier.NumberHolderImpl", cc -> {
            cc.extends_(anh);
            // add some fields for context
            FieldDesc numberDesc = cc.field("number", Const.of(100));
            // add a default ctor
            cc.defaultConstructor();
            // we need this in order for our instance methods to do something interesting
            This this_ = cc.this_();
            // add a non-public ctor with an implicitly defined type
            cc.constructor(mc -> {
                mc.packagePrivate();
                ParamVar number = mc.parameter("number", int.class);
                mc.body(b0 -> {
                    b0.set(this_.field(numberDesc), number);
                    b0.return_();
                });
            });
            // method with implicitly defined type
            cc.method("incrementNumber", mc -> {
                mc.addAnnotation(Override.class);
                mc.public_();
                mc.returning(int.class);
                mc.body(b0 -> {
                    b0.inc(this_.field(numberDesc));
                    b0.return_(this_.field(numberDesc));
                });
            });
            // method with explicitly defined type
            cc.method("setNumber", MethodTypeDesc.of(
                ClassDesc.ofDescriptor("V"),
                ClassDesc.ofDescriptor("I")
            ), mc -> {
                mc.addAnnotation(Override.class);
                // parameters must match
                ParamVar newNumber = mc.parameter("newNumber");
                mc.body(b0 -> {
                    b0.set(this_.field(numberDesc), newNumber);
                    b0.return_();
                });
            });
        });
    }
}
----

Conventionally, we use `mc` as the name of the lambda parameter which accepts the method or constructor builder.
Since `cc` is conventionally used for classes, we use `mc` even for constructors.

[id=parameters]
=== Parameters

Methods and constructors may optionally accept parameters.
Parameters are declared using the `parameter(...)` method as shown in the example above.
The return value of the `parameter(...)` method is an object of type `ParamVar` which may be used as a variable (see <<local-vars>> for information about accessing variable values).

All parameters must be defined before defining the body of the method or constructor.
If the method or constructor was defined with a type, the defined parameters must match the number and type of parameters in the type.
Otherwise, the type of the method or constructor is derived from the parameters (and the return type, in the case of constructors).

[id=initializers]
=== Initializers

As a special case of constructors, static and instance initializers may be added to types as well.
Static initializers may be added to classes or interfaces using the `staticInitializer(...)` method.
Instance initializers only apply to classes, and may be defined using the `initializer(...)` method.

All defined static initializers and static field initializers are assembled into a single static initializer analogously to how the Java compiler does so, in order of definition.

Instance initializers and instance field initializers are all assembled into a single code block, which is then automatically replicated into each instance constructor.

[id=modifiers]
== Access levels and modifiers

Types, members, and variables in Java have an access level (specifically, `private`, package-private, `protected`, or `public`) as well as modifier flags (e.g. `volatile`, `final`, `synchronized`, etc.).

Access levels are represented using the `AccessLevel` enumeration.
Generally speaking, any type, member, or variable which is being built can have its access level set using the `setAccess(...)` method on its creator instance.
In most cases, there will also be convenience methods to set the valid access levels (`public_()`, `private_()`, etc.) which are equivalent to calling `setAccess(...)` with the corresponding access level as an argument.

Most things default to `PUBLIC`, other than (for example) fields or native methods, which generally default to `PRIVATE`.
The detailed breakdown of initial default modifiers is described <<default-modifiers,below>>.

Not every item supports every access level.
Attempting to set an access level which is not valid for the given target will result in an exception.
To determine if an access level is valid for the item, the `supports(...)` method may be used, passing in the `AccessLevel` as an argument.

Modifier flags are represented using the `ModifierFlag` enumeration.
Modifier flags may be added using the `addFlag(...)` method and removed using the `removeFlag(...)` method.

Like access levels, modifier flags are not always valid for every kind of creator.
Unlike access levels, there are some cases where a modifier flag is always present (for example, `static` when <<creating-methods,creating a static method>>).
Attempting to remove such flags will result in an exception; however, redundantly adding flags that are already present is allowed.
Likewise, removing a flag which it not allowed on the given type, member, or variable is always allowed.

The `ModifierLocation` enumeration lists all of the places where an access level or modifier flag may appear.
The constants in this enumeration may also be used to test whether a modifier is allowed or is forbidden on the corresponding location.

Any creator which accepts a modifier or access level extends the `ModifiableCreator` interface.
This interface can be used to determine the modifier location of the creator by way of the `modifierLocation()` method.
The `supports(...)` method can also be used to determine whether a modifier flag or access level may be used on that creator.

.Example of access levels and modifier flags
[source,java]
----

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.BlockCreator;
import io.quarkus.gizmo2.creator.ModifierFlag;

public class ModifiersAndAccessLevelsExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("org.example.ModifiersAndAccessLevels", cc -> {
            // set the access level by enumeration
            cc.setAccess(AccessLevel.PACKAGE_PRIVATE);
            // or by direct method call
            cc.packagePrivate();
            // last one written "wins"
            cc.public_();
            // flags can be added by enumeration
            cc.addFlag(ModifierFlag.FINAL);
            // or by method call
            cc.final_();
            // flags can be removed even if they are not supported here
            cc.removeFlag(ModifierFlag.STATIC);
            cc.field("exampleField", fc -> {
                fc.setType(String.class);
                // set access by enumeration
                fc.setAccess(AccessLevel.PROTECTED);
                // or method call
                fc.protected_();
                // flags by enumeration
                fc.addFlag(ModifierFlag.TRANSIENT);
                // or call
                fc.volatile_();
            });

            cc.staticField("staticField", fc -> {
                fc.setType(int.class);
                fc.setInitial(12345);
                // set access
                fc.private_();
                // and flags
                fc.final_();
                // we can add redundant flags
                fc.addFlag(ModifierFlag.STATIC);
                // but we cannot remove them
            });

            cc.method("exampleMethod", mc -> {
                // add flag by enumeration
                mc.addFlag(ModifierFlag.BRIDGE);
                // or by method call
                mc.final_();
                // set access level by enumeration
                mc.setAccess(AccessLevel.PUBLIC);
                // or method call
                mc.public_();
                mc.parameter("aFinalInt", pc -> {
                    pc.setType(int.class);
                    // no access levels are supported on parameters!
                    /* pc.setAccess(xxx); */
                    // flags can be added to parameters
                    pc.addFlag(ModifierFlag.FINAL);
                    // by method call too
                    pc.final_();
                    // but note that "final" doesn't have any practical
                    // effect on parameters or local variables
                });
                // stub an empty body that returns nothing
                mc.body(BlockCreator::return_);
            });
        });
    }
}
----

[id=default-modifiers]
=== Changing default access levels and modifiers

Instances of <<gizmo-interface,the `Gizmo` interface>> are configured with the set of default modifiers and access levels for the different `ModifierLocation` instances.
Instances of `Gizmo` are immutable; however, it is possible to create a derived `Gizmo` instance with a different configuration of default access levels and/or modifier flags using the `withDefaultModifiers` method.

.Changing the default modifiers
[source,java]
----
import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;
import io.quarkus.gizmo2.creator.AccessLevel;
import io.quarkus.gizmo2.creator.ModifierFlag;
import io.quarkus.gizmo2.creator.ModifierLocation;

public class DefaultModifiersExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        // the `newGizmo` has updated defaults
        Gizmo newGizmo = gizmo.withDefaultModifiers(mc -> {
            // add the `synthetic` flag to all interfaces
            mc.add(ModifierLocation.INTERFACE, ModifierFlag.SYNTHETIC);
            // make all abstract methods be `protected`
            mc.set(ModifierLocation.CLASS_ABSTRACT_METHOD, AccessLevel.PROTECTED);
            // remove the `synthetic` flag from all classes
            mc.remove(ModifierLocation.CLASS, ModifierFlag.SYNTHETIC);
        });
    }
}
----

By default, the following modifier flags and access levels are used if none is given:

[%header,cols=*]
|===
|Location|Access Level|Modifier Flags
|`INTERFACE_DEFAULT_METHOD`|`PUBLIC`|(none)
|`INTERFACE_PRIVATE_INSTANCE_METHOD`|`PRIVATE`|(none)
|`INTERFACE_ABSTRACT_METHOD`|`PUBLIC`|`ABSTRACT`
|`INTERFACE_STATIC_FIELD`|`PUBLIC`|`STATIC`
|`INTERFACE_STATIC_METHOD`|`PUBLIC`|`STATIC`
|`CLASS_CONSTRUCTOR`|`PUBLIC`|(none)
|`CLASS_INSTANCE_METHOD`|`PUBLIC`|(none)
|`CLASS_ABSTRACT_METHOD`|`PUBLIC`|`ABSTRACT`
|`CLASS_NATIVE_METHOD`|`PRIVATE`|(none)
|`CLASS_STATIC_METHOD`|`PUBLIC`|`STATIC`
|`CLASS_INSTANCE_FIELD`|`PRIVATE`|(none)
|`CLASS_STATIC_FIELD`|`PRIVATE`|`STATIC`
|`CLASS`|`PUBLIC`|`SYNTHETIC`
|`INTERFACE`|`PUBLIC`|`SYNTHETIC`, `ABSTRACT`
|`ANONYMOUS_CLASS`|`PRIVATE`|`SYNTHETIC`
|`PARAMETER`|(none)|(none)
|`LOCAL_VARIABLE`|(none)|(none)
|===

[id=blocks]
== Blocks

Blocks are created using instances of the `BlockCreator` interface.
This interface is not instantiated directly.
Rather, instances will be passed in to callbacks which build the block within contexts that require bytecode, such as initializers or method bodies.

Blocks are executed from the first instruction (top) to the last instruction of the block (bottom).
Normally, control leaves a block by falling through the bottom;
however, there are two main exceptions to this rule.
The first is when control is abruptly terminated (for example, a call to a method which throws an exception, or a `return_` within a nested conditional).
The second is certain control flow constructs, like <<if,`if_`>> or <<switch,`switch_`>>, where control flow might follow only one of several possible branches, and control would then resume with the next instruction after the control flow construct.

Additionally, there are some cases where control flow is _forbidden_ from falling through the bottom of the block.
Specifically, it is an error for the outermost block of a method or constructor to terminate in any way other than <<return,returning a value>> or <<throw,throwing an exception>>.

If Gizmo detects an instruction which is added to a block in an impossible-to-reach location (for example, immediately after a `return_`), an exception is thrown.
Use the `done()` method on `BlockCreator` to determine whether it has been terminated in cases where it cannot be easily known.

[id=scoping]
=== Scoping

In Gizmo 2, the code of methods and constructors is organized into lexically scoped _blocks_.
These scopes mirror the way that blocks are constructed by the API.
<<local-vars,Local variables>> are confined to the lexical scope in which they are declared.
<<parameters,Method and constructor parameters>> are always declared outside the outermost block, and thus they are accessible throughout the code of the method or constructor.

Since blocks are thus nested hierarchically, it is conventional to use the variable names `b0`, `b1`, `b2`, etc. to represent the nesting level.

.Example of simple block nesting
[source,java]
----

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Gizmo;

public class BlockNestingExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NestingExample", cc -> {
            cc.staticInitializer(b0 -> {
                // we're in the outermost block
                b0.block(b1 -> {
                    // this is a nested block
                    b1.block(b2 -> {
                        // nested even deeper
                    });
                });
            });
        });
    }
}
----

[id=expressions]
== Expressions

Every operation yields an _expression_ which represents the result of that operation, represented by instances of the `Expr` interface.
Expressions may then be used as inputs to other operations.
Each expression has <<types,a type>> (which may be `void`).
Some expressions are also <<assignable,assignable>>, and some are <<constants,constants>>.
These expression types have special properties which are described below.

[id=expressions-use]
=== How to use expressions correctly

Expressions which are not <<constants,constants>> or <<assignable,variables>> may only be used once, and must be used in the same order in which they were created.
Gizmo _may_ make some minimal effort to order expressions correctly, however this should not be relied on.
Normally, correct ordering is a consequence of writing an expression in the natural way (left to right, innermost to outermost) so most of the time this is not a concern.
Violating this rule will result in an exception with a message like `Item is not at its expected location`.

A good rule of thumb is that if you ever create or extract a Java variable whose type is `Expr`, it should be stored into a <<local-vars,local variable>>.
Variables, like constants, can be used multiple times and in any position.

Here's an example:

.Example of natural expression ordering
[source,java]
----

import java.nio.file.Path;

import io.quarkus.gizmo2.ClassOutput;
import io.quarkus.gizmo2.Const;
import io.quarkus.gizmo2.Gizmo;

public class NaturalOrderingExample {
    public static void main(String[] args) {
        Gizmo gizmo = Gizmo.create(ClassOutput.fileWriter(Path.of("output")));
        gizmo.class_("NaturalOrdering", cc -> {
            cc.staticMethod("main", mc -> {
                mc.public_();
                mc.parameter("args", String[].class);
                mc.body(b0 -> {
                    // each arithmetic op yields an expression
                    b0.printf("The answer is: %d%n",
                        b0.add(
                            b0.mul(
                                Const.of(100),
                                Const.of(23)
                            ),
                            b0.div(
                                Const.of(512),
                                Const.of(8)
                            )
                        )
                    );
                    b0.return_();
                });
            });
        });
    }
}
----

[id=types]
=== Types

[id=constants]
=== Constants

[id=const]
==== The `Const` interface

[id=jdk-const]
==== The `ConstantDesc` and `Constable` interfaces

[id=condy]
==== Dynamic constants

[id=this]
=== The special `this` expression

[id=assignable]
=== Assignable expressions

[id=local-vars]
==== Local variables

[id=fields]
==== Field expressions

[id=array-elements]
==== Array element expressions

[id=variable-use]
==== Using variable values

[id=variable-mutate]
==== Mutating variables

[id=variable-atomics]
==== Atomic operations on variables

[id=void-expr]
=== Void expressions

[id=yielding]
=== Yielding values from blocks

[id=arithmetic]
=== Arithmetic expressions

xxx: `add`/`sub`/`mul`/`div`/`mod`/`neg`

[id=bitwise-logic]
=== Bitwise logical expressions

xxx: `and`/`or`/`xor`/`complement`

[id=bitwise-shift]
=== Bitwise shifting expressions

xxx: `shl`/`shr`/`ushr`

[id=relational]
=== Relational expressions

[id=equality]
==== Equality/inequality

xxx: `eq`/`ne`

[id=numerical-relations]
==== Numerical relations

xxx: `lt`/`le`/`gt`/`ge`

[id=comparator-like]
==== Comparator-like operations

xxx: `cmp`/`cmpl`/`cmpg`

[id=invocation]
=== Invocation expressions

[id=invoke-static]
==== `invokeStatic`

[id=invoke-virtual]
==== `invokeVirtual`

[id=invoke-interface]
==== `invokeInterface`

[id=invoke-special]
==== `invokeSpecial`

[id=new]
=== `new` expression

[id=new-array]
=== `newArray` expression

[id=anonymous]
=== Anonymous class expressions

[id=lambdas]
=== Lambda expressions

[id=control]
== Control flow

[id=block]
=== `block`

[id=break]
=== `break`

[id=return]
=== `return_`

[id=throw]
=== `throw_`

[id=goto]
=== `goto`/`gotoStart`

[id=if]
=== `if`/`cond`

[id=logical]
=== `logicalAnd`/`logicalOr`

[id=switch]
=== `switch` and `switchEnum`

[id=goto-case]
==== `gotoCase`/`gotoDefault`

[id=loop]
=== `loop`

[id=while]
=== `while`/`doWhile`

[id=for-each]
=== `forEach`

[id=continue]
=== `continue_`

[id=try]
=== `try_`

[id=synchronized]
=== `synchronized_`

[id=auto-close]
=== `autoClose`

[id=annotations]
== Adding annotations

(TODO more detail)

[id=helpers]
== Helper methods

[id=assertions]
=== Assertions

[id=expr-equals]
=== `exprEquals`/`exprHashCode`/`exprToString`

[id=array-equals]
=== `arrayEquals`/`arrayHashCode`/`arrayToString`

[id=class-for-name]
=== `classForName`

[id=close]
=== `close`/`autoClose`

[id=iterate]
=== `iterate`

[id=current-thread]
=== `currentThread`

[id=optional]
=== `optionalOf`/`optionalOfNullable`

[id=collection-of]
=== `mapOf`/`setOf`/`listOf`/`mapEntryOf`

[id=swap]
=== `swap`/`rotate`

[id=boxing]
=== `box`/`unbox`

[id=locked]
=== `locked`

[id=fences]
=== Fences

[id=wrappers]
== Object wrappers

(TODO list them)

[id=generic-type]
== Generic types and type annotations

[id=building-generic-types]
=== Building generic types

[id=type-variables]
=== Adding type variables

[id=debugging]
== Debugging tips

[id=source-file-line]
=== Adding source file name and line numbers
